<?xml version="1.0" encoding="utf-8"?>
<mx:Application xmlns:mx="http://www.adobe.com/2006/mxml" layout="absolute" 
	xmlns:flex="com.modestmaps.flex.*" implements="commentspace.IStatefulVis" 
	horizontalScrollPolicy="off" verticalScrollPolicy="off" xmlns:ns1="components.*">
	
	<mx:Canvas id="container" width="100%" height="100%" backgroundColor="0xffffff" 
		horizontalScrollPolicy="off" verticalScrollPolicy="off" creationComplete="{setupMap()}"/>
	
	<mx:VBox left="15" top="15" right="15" width="100">
		<mx:VBox id="plots" width="100%" verticalGap="8">
		</mx:VBox>
		<mx:LinkButton label="load data" click="{triggerLoadingPopup()}" />
		<ns1:AirQualityLegend top="230" left="15" width="150" height="160"/>
	</mx:VBox>
	

	<mx:Script>
		<![CDATA[
			import events.CSEvent;
			import events.DataPointEvent;
			import components.AirQualityScatterPlot;
			import mx.managers.PopUpManager;
			import components.loading.DataLoadingPanel;
			import components.AirQualityMapLayer;
			import etc.AirQualityColors;
			import mx.messaging.AbstractConsumer;
			import mx.effects.Zoom;
			import com.modestmaps.mapproviders.microsoft.MicrosoftHybridMapProvider;
			import com.modestmaps.events.MarkerEvent;
			import components.MarkerManager;
			import com.modestmaps.TweenMap;
			import com.modestmaps.extras.ui.Button;
			import mx.events.ResizeEvent;
			import com.modestmaps.events.MapEvent;
			import commentspace.StatefulVisEvent;
			import com.modestmaps.overlays.MarkerClip;
			import mx.events.MenuEvent;
			import mx.controls.Menu;
			import components.FlagMarker;
			import com.modestmaps.Map;
			import com.modestmaps.extras.ZoomSlider;
			import com.modestmaps.extras.MapControls;
			import flash.sampler.Sample;
			import com.modestmaps.geo.Location;
			
			/******** Embedded Assets **********************************************************/
			[Embed(source="assets/flag_blue.png")]
			protected const BlueFlagIcon:Class;
			[Embed(source="/assets/comment_flag.png")]
			protected const CommentIcon:Class;
			[Embed(source="assets/cross.png")]
			protected const CancelIcon:Class;
			
			
			/******** Source Data **********************************************************/
			//[Embed(source = "assets/2009-05-14 (West Oakland PM + GPS).csv", mimeType="application/octet-stream")]
			//protected const Embedded20090514PMData:Class;
			protected const outside20090514PMData:String = "http://www.eecs.berkeley.edu/~willettw//temp/2009-05-14%20(West%20Oakland%20PM%20+%20GPS).csv?";

			
			/******** Constants **********************************************************/
			protected const CLICK_RADIUS:Number = 2;
			
			protected static const DESATURATION_MATRIX:Array = [
					0.3, 0.59, 0.3, 0, 0,
		            0.3, 0.59, 0.3, 0, 0,
		            0.3, 0.59, 0.3, 0, 0,
		            0, 0, 0, 0.5, 0
		        ];
			
			/******** Local Vars **********************************************************/
			protected var maxPoints:int = 1000;
			
			//the map!
			protected var map:TweenMap;
			
			//Clip the flags are drawn into
			protected var _flagsClip:MarkerClip;
			
			//Clip the textures are drawn into
			protected var _plotLayer:AirQualityMapLayer;
			
			//An object containing lists of data points (as Vector.<Object>) indexed by the URI they were loaded from
			protected var _dataSets:Object = {};
			
			
			//protected var dataSource:Object = Embedded20090514PMData;
			protected var dataSource:Object = outside20090514PMData;
			
			//flag to prevent updated events from being dispatched during panAndZoomTo runs
			protected var _isPanningAndZooming:Boolean = false; 
			
			
			
			/******** Mapping Methods **********************************************************/
			protected function setupMap():void{
				
				
				map = new TweenMap();
				map.setMapProvider(new MicrosoftHybridMapProvider(10,19));
				map.grid.filters = [new ColorMatrixFilter(DESATURATION_MATRIX)];
				container.rawChildren.addChild(map);
				
				map.x = 0;
				map.y = 0;
				map.setSize(container.width,container.height);
				
				map.panDuration = 0.6;
				map.zoomDuration = 0.5;
				map.panAndZoomDuration = 0.6;
				
				_plotLayer = new AirQualityMapLayer(map);
				_flagsClip = new MarkerClip(map);
				map.addChild(_plotLayer);
				map.addChild(_flagsClip);
				
				map.addChild(new MapControls(map));

				//set the map center
				map.setCenterZoom(new Location(37.803,-122.298),14);
				
				//Listeners for triggering menus
				map.addEventListener(MouseEvent.MOUSE_DOWN, handleMouseDown);
				map.addEventListener(MouseEvent.MOUSE_UP, handleClick);

				//Listeners for updating state 
				map.addEventListener(MapEvent.STOP_PANNING, dispatchUpdated);
				map.addEventListener(MapEvent.STOP_ZOOMING, dispatchUpdated);
				map.addEventListener(CSEvent.PAN_AND_ZOOM_COMPLETE, dispatchUpdated);
				
				//Listeners for handling marker highlighting				
				map.addEventListener(MapEvent.STOP_PANNING,maintainHighlights);
				map.addEventListener(MapEvent.STOP_ZOOMING,maintainHighlights);
				map.addEventListener(CSEvent.PAN_AND_ZOOM_COMPLETE,maintainHighlights);
				
				this.addEventListener(ResizeEvent.RESIZE,onResize);
					
				//Plot data and existing markers
				//loadFileData(dataSource,AirQualityColors.PM_25_24HR,function():void{
						//plot any flag markers
						plotExistingMarkers();	
						//let commentspace know we're loaded				
						dispatchComplete();
				//	});
			}
			
			
			protected function loadFileData(source:Object,pollutant:String,onComplete:Function=null):void{
			
				var dataURI:String = source.toString(); 
			
				//Add a scatterplot to represent the datafile
				var scatterPlot:AirQualityScatterPlot = addScatterPlot(dataURI,dataURI);
				scatterPlot.pollutant = pollutant;
				_plotLayer.pollutant = pollutant;
				
				//helper method for processing loaded CSV data.
				var processLoaded:Function = function(data:String):void{
						var entries:Array = data.split(/\r|\n/gi);
						
						_dataSets[dataURI] = new Vector.<Object>();
						if(entries.length > 1){
							var headers:Array = (entries[0] as String).split(',');
							
							for(var i:int = 1; i < entries.length; i++){
								var entry:Array = (entries[i] as String).split(',');
								if(headers.length != entry.length && i < entries.length - 1){
									throw new Error("Row " + i + ":(" + entries[i] + ") from data source \"" + 
										dataURI + "\" has a different number of elements than the header row:(" +
										entries[0] + ").");  
								}  
								var pointData:Object = {}
								for(var h:int=0;h < headers.length;h++) pointData[headers[h]] = entry[h]; 
								_dataSets[dataURI].push(pointData);
							}
							
							//add a new scatterplot if necessary
							scatterPlot.data = _dataSets[dataURI];
							_plotLayer.data = _dataSets;
							_plotLayer.refresh(true);
							
						}
						if(onComplete != null)onComplete();
					}
					
				var handleProgress:Function = function(pe:ProgressEvent):void{
						scatterPlot.progressBar.setProgress(pe.bytesLoaded,pe.bytesTotal);
						scatterPlot.progressBar.label = (int(pe.bytesLoaded / pe.bytesTotal * 100) + 
							"% (" + pe.bytesLoaded + " of " + pe.bytesTotal + " bytes)");
					}
				
				//Handle embedded data		
				if(source is Class) processLoaded(new (source as Class)());
				//Load data from the web
				else if(source is String){
					var request:URLRequest = new URLRequest(source as String);
					var loader:URLLoader = new URLLoader(request);
					loader.addEventListener(Event.COMPLETE,function(e:Event):void{
							scatterPlot.progressBar.visible = false;
							processLoaded(loader.data as String);
						});
					loader.addEventListener(ProgressEvent.PROGRESS,handleProgress);
						
				}
				else throw new ArgumentError("Invalid data source. Source should either " + 
						"be the URI of a text file containing data or a Class containing " + 
						"an embedded text file.");
			}
			
			
			protected function addScatterPlot(dataURI:String,plotName:String=""):AirQualityScatterPlot{
				var newPlot:AirQualityScatterPlot = new AirQualityScatterPlot();
				newPlot.percentWidth = 100;
				newPlot.displayName = plotName;
				newPlot.dataField = "value";
				newPlot.data = _dataSets[dataURI];
				plots.addChild(newPlot);
				
				//add listeners to handle linking
				var clickPlot:Function = function(de:DataPointEvent):void{
						if(de.dataPoint){
							var loc:Location = new Location(de.dataPoint.lat,de.dataPoint.lon); 
							panAndZoomTo(loc,map.getZoom());
						}
					};
				var drawLayerTip:Function = function(de:DataPointEvent):void{
						_plotLayer.drawDataTip(de.dataPoint);
					};
				var drawPlotTip:Function = function(de:DataPointEvent):void{
						newPlot.drawDataTip(de.dataPoint);
					};
				var discardLayerTip:Function = function(de:DataPointEvent):void{
						_plotLayer.discardActiveDataTip();
					};
				var discardPlotTip:Function = function(de:DataPointEvent):void{
						newPlot.discardActiveDataTip();
					};
				newPlot.addEventListener(DataPointEvent.CLICK,clickPlot);
				newPlot.addEventListener(DataPointEvent.HOVER,drawLayerTip);
				_plotLayer.addEventListener(DataPointEvent.HOVER,drawPlotTip);
				newPlot.addEventListener(DataPointEvent.UNHOVER,discardLayerTip);
				_plotLayer.addEventListener(DataPointEvent.UNHOVER,discardPlotTip);
				
				//Handle removal when necessary						
				newPlot.addEventListener(CSEvent.REMOVE_CLICKED,function(ce:CSEvent):void{			
						newPlot.removeEventListener(DataPointEvent.HOVER,drawLayerTip);
						_plotLayer.removeEventListener(DataPointEvent.HOVER,drawPlotTip);
						newPlot.removeEventListener(DataPointEvent.UNHOVER,discardLayerTip);
						_plotLayer.removeEventListener(DataPointEvent.UNHOVER,discardPlotTip);
						
						plots.removeChild(newPlot);
						delete _dataSets[dataURI];
						_plotLayer.refresh(true);
					});
				
				return newPlot;
			}
			
			
			/**
			 * Plots and persisted markers from the MarkerManager
			 * 
			 */
			protected function plotExistingMarkers():void{
				var markers:Array = MarkerManager.getMarkers();
				for each(var m:FlagMarker in markers) attachMarker(m);
			}
			


			/**
			 * Click handlers for the marker menu - ensures the
			 *  menu isn't popped up on drags
			 */ 
			protected var _mouseDownXY:Point;
			protected function handleMouseDown(me:MouseEvent):void{
				_mouseDownXY = map.globalToLocal(new Point(me.stageX, me.stageY));
			}
			protected function handleClick(me:MouseEvent):void{
				var newMouseXY:Point = map.globalToLocal(new Point(me.stageX, me.stageY));
				if(me.target is FlagMarker ||
					me.target is Button ||
					!_mouseDownXY ||
					newMouseXY.x < _mouseDownXY.x - CLICK_RADIUS ||
					newMouseXY.x > _mouseDownXY.x + CLICK_RADIUS || 
					newMouseXY.y < _mouseDownXY.y - CLICK_RADIUS ||
					newMouseXY.y > _mouseDownXY.y + CLICK_RADIUS) return;
				
				var mouseXY:Point = new Point(me.stageX, me.stageY);
				var loc:Location = map.pointLocation(_mouseDownXY);
				createMenu(mouseXY,loc);
			}
			
			
			/** Pops up a menu that allows markers to be
			 *   added to the display.
			 */
			protected function createMenu(mousePt:Point,location:Location):void{
				//set up menu XML
				var menuXML:XML = XML(<root/>);
				var addXML:XML = XML(<item/>);
				addXML.@label = 'Comment on this Location';	
				addXML.@icon = 'CommentIcon';
				addXML.@event = 'add';
				menuXML.appendChild(addXML);
				var cancelXML:XML = XML(<item/>);
				cancelXML.@label = 'Cancel';
				cancelXML.@icon = 'CancelIcon';
				cancelXML.@event = 'cancel';
				menuXML.appendChild(cancelXML);

				//build and display menu
				var menu:Menu = Menu.createMenu(map,menuXML,false);
				menu.labelField = "@label";
				menu.iconFunction = iconFunction;
				menu.addEventListener(MenuEvent.ITEM_CLICK,function(me:MenuEvent):void{
						//when Add is clicked - add a marker
						if(me.item.@event == 'add'){
							var m:FlagMarker = new FlagMarker(location,map.getZoom());
							attachMarker(m);
							MarkerManager.saveMarker(m);
							//once the pan is completed, dispatch an event
							map.addEventListener(MapEvent.STOP_PANNING,function(e:Event):void{
									map.removeEventListener(MapEvent.STOP_PANNING,arguments.callee);
									map.dispatchEvent(new CSEvent(CSEvent.COMMENT_MARKER_ADDED,m,true));
								});
							map.panTo(location);
						}
						//otherwise, hide the menu
						else menu.hide();
					});
					
	            menu.show(mousePt.x, mousePt.y);
			}
			
			
			/**
			 * Attaches a flag marker to the visualiation using 
			 *  the location specified on it.
			 */
			protected function attachMarker(marker:FlagMarker):void{
				_flagsClip.attachMarker(marker,marker.location);
				marker.addEventListener(MouseEvent.CLICK, function(me:MouseEvent):void{
						var ft:FlagMarker = (me.currentTarget as FlagMarker); 
						panAndZoomTo(ft.location, ft.zoom);
						//secret click-to delete function
						if(me.shiftKey && me.ctrlKey){
							_flagsClip.removeMarker(ft.name);
							MarkerManager.deleteMarker(ft);
						}
					});				
			}
			
			
			/**
			 * Pans and zooms to a specific point and zoom level.
			 *  If this takes longer than expected, cut to the chase and just jump 
			 *  to the specified loc/zoom - this circumvents a bug where modest maps
			 *  can hang indefinitely when panning.
			 */
			protected function panAndZoomTo(loc:Location,zoom:int):void{
				
				if(_isPanningAndZooming) return; //don't try to run if one is underway
				_isPanningAndZooming = true;
				var mapZoom:int = map.getZoom();
				
				//We'll skip to the point if the pan takes 50% longer than expected. 
				var t:Timer = new Timer(1000 * map.panDuration * 1.5);
				
				//If panning completes successfully, then zoom
				var onPZPan:Function = function(me:MapEvent):void{
						map.removeEventListener(MapEvent.STOP_PANNING,onPZPan);
						map.zoomByAbout(zoom - mapZoom);
					}
				
				//If zooming completes or the timer expires, do a final recenter and dispatch events
				var onPZComplete:Function = function(e:Event=null):void{
						
						//Remove listeners
						t.stop();
						t.removeEventListener(TimerEvent.TIMER,onPZComplete);
						map.removeEventListener(MapEvent.STOP_PANNING,onPZPan);
						map.removeEventListener(MapEvent.STOP_ZOOMING,onPZComplete);
						
						
						var newCenter:Location = map.getCenter();
						var newZoom:Number = map.getZoom();
						
						//Recenter if our zooming misaligns the result of the pan
						if(!locEquals(loc,newCenter)){
							map.setCenter(loc);
						} 
						if(newZoom != zoom){
							 map.setZoom(zoom);	
						}
						
						if(!locEquals(loc,newCenter) || map.getZoom() != zoom){
							newCenter = map.getCenter(); newZoom = map.getZoom();
							trace("Error: Center and Zoom still are not correct after realign!");
						}
						
						_isPanningAndZooming = false;
						map.dispatchEvent(new CSEvent(CSEvent.PAN_AND_ZOOM_COMPLETE));
					}				
							
				//Add Listeners
				map.addEventListener(MapEvent.STOP_PANNING, onPZPan);
				map.addEventListener(MapEvent.STOP_ZOOMING, onPZComplete);
				t.addEventListener(TimerEvent.TIMER, onPZComplete);
								
				//Start the panning an timer
				t.start();
				map.panTo(loc);
			}
			
			
			/******** Implements IStatefulVis *************************************************/	
				
			protected var _isVisCreationComplete:Boolean = false;	
			public function get isVisCreationComplete():Boolean{ return _isVisCreationComplete; }
				
			
			public function get state():Object{
				var cz:Array = map.getCenterZoom();
				var cl:Location = roundLocation(cz[0] as Location);
				var ds:String = "";
				for(var d:String in _dataSets) ds += (d + ",");
				if(ds.length > 0)ds = ds.slice(0,ds.length - 1);
				return {centerLat:cl.lat,centerLon:cl.lon,zoom:cz[1],dataSource:ds};
			}
			
			public function set state(o:Object):void{
				panAndZoomTo(new Location(o.centerLat,o.centerLon),o.zoom);
			}
			
			protected function dispatchComplete(e:Event = null):void{
				_isVisCreationComplete = true;
				dispatchEvent(new StatefulVisEvent(StatefulVisEvent.VIS_CREATION_COMPLETE,true));
			}
			
			protected function dispatchUpdated(e:Event = null):void{
				if(_isPanningAndZooming) return; //don't dispatch during the middle of a panAndZoom() run
				dispatchEvent(new StatefulVisEvent(StatefulVisEvent.VIS_UPDATE,true));
			}
			
			/* Security settings - should be constrained before deployment!
			 *  These settings allow this code to be loaded into and accessed by 
			 *  a Flash movie on ANY external server. *****************************/
			Security.allowDomain("*");
			Security.allowInsecureDomain("*");
			
			
			/******** Helper Methods **********************************************************/
				
			public function onResize(event:Event):void
			{	
				var mc:Location = map.getCenter(); 
				map.setSize(this.width, this.height);
				map.setCenter(mc);
				
			}	
				
				
			protected function maintainHighlights(e:Event=null):void{
				if(_isPanningAndZooming) return; 
				for (var i:int = 0; i < _flagsClip.numChildren; i++){
					var m:FlagMarker = _flagsClip.getChildAt(i) as FlagMarker;
					var ml:Location = map.getCenter();
					var mz:int = map.getZoom();
					m.highlight(locEquals(m.location,ml) && m.zoom == mz);
				}
			}
			
			/**Checks if two locations are equal to some level of precision */
			protected function locEquals(a:Location,b:Location,precision:uint=10):Boolean{
				return (a.lat.toPrecision(precision) == b.lat.toPrecision(precision) 
					&& a.lon.toPrecision(precision) == b.lon.toPrecision(precision));
			}
			
			/**Returns a location with lat/lon rounded to some level of precision */
			protected function roundLocation(l:Location,precision:uint=10):Location{
				return new Location(Number(l.lat.toPrecision(precision)),Number(l.lon.toPrecision(precision)));
			}
				
				
			/**
			 * A workaround which sets icons in the menus using a 
			 *  function since the standard @icon attribute in the
			 *  XML doesn't work unless the imports are at the application
			 *  root. 
			 * @param o
			 * @return 
			 * 
			 */		
			protected function iconFunction(o:Object):Class{
				if((o as XML).attributes().icon){
					var iconName:String = o.@icon;
					var iconClass:Class = this[iconName] as Class;
					return iconClass;				
				}
				else return null;
			}
			
			
			/**
			 * Triggers a popup display that allows data to be loaded from
			 *  outside.
			 */
			protected function triggerLoadingPopup():void{
				var dataPanel:DataLoadingPanel = new DataLoadingPanel();
				
				//when the okay button is clicked
				dataPanel.onLoadClick = function(e:Event=null):void{
						var url:String = dataPanel.selectedURL;
						var pollutant:String = dataPanel.selectedItem.reading;
						if(url) loadFileData(url,pollutant);
						PopUpManager.removePopUp(dataPanel);
					};
					//when the cancel button is clicked
					//when the okay button is clicked
				dataPanel.onCancelClick = function(e:Event=null):void{
						PopUpManager.removePopUp(dataPanel);
					};
				PopUpManager.addPopUp(dataPanel,this,true);
				PopUpManager.centerPopUp(dataPanel);
			}
			
		]]>
	</mx:Script>
	
</mx:Application>
