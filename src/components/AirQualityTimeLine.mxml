<?xml version="1.0" encoding="utf-8"?>
<mx:Canvas xmlns:mx="http://www.adobe.com/2006/mxml" xmlns:display="flash.display.*"  height="70"
	backgroundColor="0xDDCCCCCC" backgroundAlpha="0.8" 
	horizontalScrollPolicy="off" verticalScrollPolicy="off">
	
	<mx:VRule id="tipLine" top="{margin}" bottom="{margin}" visible="false"/>
	
	<mx:Canvas id="container"  x="{margin + 30}" width="100%" height="100%" resize="{refresh()}" 
		mouseOver="{handleMouseMove(event)}" mouseOut="{handleMouseOut(event)}" 
		mouseMove="{handleMouseMove(event)}" click="{handleMouseClick(event)}" 
		doubleClick="{handleDoubleClick(event)}"
		horizontalScrollPolicy="off" verticalScrollPolicy="off"
		doubleClickEnabled="true" />
		
	<mx:Canvas id="labels" mouseEnabled="false" x="{margin + 30}" width="100%" height="100%" />
	<mx:Button id="zOut" click="{zoomOut()}" label="-" toolTip="zoom out" 
			x="{margin}" y="{margin + 25}" paddingLeft="0" paddingRight="0" width="25"/>
	<mx:Button id="zIn" click="{zoomIn()}" label="+" 
			toolTip="zoom in" width="25" paddingLeft="0" 
			paddingRight="0" y="{margin}" x="{margin}"/>
	
	<mx:Script>
		<![CDATA[
			import events.DataSetEvent;
			import mx.messaging.channels.PollingChannel;
			import etc.PointRenderer;
			import mx.events.CollectionEventKind;
			import mx.events.CollectionEvent;
			import data.SelectionSet;
			import data.AirQualityDataSet;
			import events.CSEvent;
			import etc.AirQualityColors;
			import events.DataPointEvent;
			import mx.controls.ToolTip;
			import mx.core.IToolTip;
			import mx.managers.ToolTipManager;
			import fl.events.ScrollEvent;
			import fl.controls.ScrollBarDirection;
			import fl.controls.ScrollBar;
			import __AS3__.vec.Vector;
			
			//------------- Public variables -----------------------------------------------
			public var xDataField:String = 'time';
			public var yDataField:String = 'value';
			public var margin:Number = 15;
			public var spacing:Number = 5;
			public var pointDiameter:Number = 6;
			public var pointOverlapTolerance:Number = 6;
			public var zoomPercentage:Number = 0.6;
			public var numMouseOverAdjacents:uint = 15;
			
			
			/**
			 * A data object should be an Object containing
			 *  sets of points (as Vector.<Object>s) 
			 *  indexed by the URI of that set of points.  
			 * @param d
			 */	
			public function get dataSets():Vector.<AirQualityDataSet>{return _dataSets;}
			public function set dataSets(d:Vector.<AirQualityDataSet>):void{
				_dataSets = d;
				refresh(true);
			}
			
			/**
			 * A set of selections to draw.
		 	 */		
			public function get selections():SelectionSet{ return _selections;}
			public function set selections(s:SelectionSet):void{
				_selections = s;
				s.addEventListener(CollectionEvent.COLLECTION_CHANGE, function(ce:CollectionEvent):void{
						if(ce.kind == CollectionEventKind.ADD){
							//for each(var o:Object in ce.items){
							refresh();									
							//}  
						}
						else if(ce.kind == CollectionEventKind.REMOVE){
							//re-render the entire view
							refresh();
						}
					});
			}
			
			
			
			public var info:Object;
			
			//------------- Data Management variables -----------------------------------------------
			protected var _dataSets:Vector.<AirQualityDataSet>;
			protected var yMin:Number;		//the lowest data value on the y axis
			protected var yMax:Number; 		//the highest data value on the y axis
			protected var xMin:Number;		//the lowest data value on the x axis
			protected var xMax:Number;		//the lowest data value on the x axis
			
			protected var xBottom:Number;	//the bottom end of the current display x-axis
			protected var xTop:Number;		//the top end of the current display x-axis

			protected var _dSetBounds:Object = {} //the screen bounds of the regions reserved for each dataset (indexed by URI)
			protected var _dSetLabels:Object = {} //labels for each dataset's region (indexed by URI)
			protected var _selections:SelectionSet; //the set of selections to draw in the current display 
			
			
			protected var _bitmap:Bitmap;
			protected var _mask:Sprite = new Sprite();
			protected var _hScroll:ScrollBar = new ScrollBar();
						
		
			//-------------Public Methods -----------------------------------------------------

			public function refresh(force:Boolean=false):void{
				if(force) calculateMinMax();
				if(isNaN(yMin) || isNaN(yMax)) return;
				else plotData();
			}
			
			
			//------------- Protected Methods -----------------------------------------------------
				
			protected function plotData(e:Event=null):void{
				
				if(!container) return;

				//clear previously drawn bitmaps
				while(container.rawChildren.numChildren > 0)container.rawChildren.removeChildAt(0);

				//If no data do nothing
				if(!dataSets || dataSets.length == 0){
					plotLabels();
					return;
				}
				
				//prep the shape object and bitmap data we'll use to draw the points
				var plotBitmapData:BitmapData = new BitmapData(container.width * 2,container.height,true,0x00FFFFFF);
				var renderer:PointRenderer = new PointRenderer(plotBitmapData,pointDiameter,pointOverlapTolerance);
															
				
				//draw outside the current range so that scrolling 
				// cuts less abruptly
				var curRange:Number = xTop - xBottom;
				var xbd:Number = Math.max(xMin,xBottom - curRange);
				var xtd:Number = Math.min(xMax,xTop + curRange);
				
				//allocate space for each point set
				_dSetBounds = {};
				var psHeight:Number = (container.height - 2 * margin - 
					(dataSets.length - 1) * spacing - 10)/dataSets.length;
				var psBounds:Rectangle = new Rectangle(container.x,container.y + margin,container.width,psHeight);

				plotBitmapData.lock();
				
				if(_dataSets && _dataSets.length > 0){
										
					//for each of the sets of points...
					for each(var ds:AirQualityDataSet in _dataSets){
						var pSet:Vector.<Object> = ds.data;
						
						//If we've already reused this renderer, ignore its previous points
						renderer.ignorePrevPoints();
						
						//set bounds for the set
						_dSetBounds[ds.dataURI] = psBounds.clone();
						plotAxes(plotBitmapData,psBounds);
						psBounds.y += (psHeight + spacing);
						
						//iterate through recorded points
						if(!ds.data) continue;
						for(var i:int=0; i < ds.data.length; i++){
							var point:Object = ds.data[i]; 
							if(point.time < xbd || point.time > xtd) continue;
						
							//determine location
							var dPt:Point = dataToPosition(point);
							
							//plot the point to the current bitmapdata
							renderer.plotPoint(point,dPt, ds.pollutant,selections.isSelected(point));
						}
					}
					
					plotBitmapData.unlock();
					
					_bitmap = new Bitmap(plotBitmapData);
					_bitmap.x = -(container.width / 2);
					
					container.rawChildren.addChild(_bitmap);
				}
				
				//set up and position the labels, scrollBar, and mask
				plotLabels();
				setupMask();
				setupScrollBar();
			}
			
			
			protected function plotAxes(bd:BitmapData,bounds:Rectangle):void{
				var plotShape:Shape = new Shape();
				
				//plot x baseline
				plotShape.graphics.lineStyle(0.5,0x999999);
				plotShape.graphics.moveTo(0,bounds.bottom);
				plotShape.graphics.lineTo(bd.width,bounds.bottom);
				
				var startDate:Date = new Date(xBottom * 1000);
				startDate.setFullYear(startDate.fullYear,startDate.month,startDate.day + 1);
				startDate.setHours(0,0,0,0);
				
				//plot days
				var d:Number = startDate.time / 1000;
				plotShape.graphics.lineStyle(0.5,0x999999,0.5);
				while(d < xTop){
					var dx:Number = (d - xBottom) * (bounds.width - 2 * margin) / 
							(xTop - xBottom) + bounds.width / 2 + margin;
					plotShape.graphics.moveTo(dx,bounds.bottom);
					plotShape.graphics.lineTo(dx,bounds.top);
					d += (24 * 3600);
				}
				
				//plot hours
				d = startDate.time / 1000;
				plotShape.graphics.lineStyle(0.5,0x999999,0.2);
				while(d < xTop){
					var dx:Number = (d - xBottom) * (bounds.width - 2 * margin) / 
							(xTop - xBottom) + bounds.width / 2 + margin;
					plotShape.graphics.moveTo(dx,bounds.bottom);
					plotShape.graphics.lineTo(dx,bounds.top);
					d += 3600;
				}
				
				//plot hours
				bd.draw(plotShape);				
			}
			
			protected function plotLabels():void{
				//remove unused labels
				for(var dl:Object in _dSetLabels){
					if(_dSetLabels[dl] && (!_dSetBounds[dl] || !_dataSets || _dataSets.length == 0)){
						labels.removeChild(_dSetLabels[dl]);						
						_dSetLabels[dl] = null;	
					}	
				}
				
				//add and update others
				for each(var d:AirQualityDataSet in _dataSets){
					if(!_dSetBounds[d.dataURI]) continue;
					if(!_dSetLabels[d.dataURI]) _dSetLabels[d.dataURI] = new TimelineLabel();
					var l:TimelineLabel = _dSetLabels[d.dataURI];
					if(d.name) l.labelText = d.name;
					l.y = _dSetBounds[d.dataURI].top;
					labels.addChild(l);
					l.onRemoveClick = function(e:MouseEvent):void{
							// a very shoddy way of finding the dataset to remove.
							//  however, just using 'd' doesn't work because of a scoping issue
							for each(var dr:AirQualityDataSet in _dataSets){
								if(dr.name == (e.target.parent as TimelineLabel).labelText){
									if(_dataSets.lastIndexOf(dr) != -1){
										_dataSets.splice(_dataSets.lastIndexOf(dr),1);
										dispatchEvent(new DataSetEvent(DataSetEvent.DATASET_REMOVED,dr));
									}
								}								
							}
						};
				}	
			}

			/**
			 * Setup and place the mask for the bitmap 
			 */ 
			protected function setupMask():void{
				_mask.graphics.clear();
				_mask.graphics.beginFill(0xFFFFFF);
				_mask.graphics.drawRect(margin - pointDiameter / 2,margin - pointDiameter / 2,
					container.width - 2 * margin + pointDiameter, container.height - margin);
				_mask.graphics.endFill();
				
				container.rawChildren.addChild(_mask);
				
				if(container.mask != _mask)container.mask = _mask;
			}
			
			
			/**
			 * Set up and place the scroll bar
			 */
			protected function setupScrollBar():void{
				_hScroll.direction = ScrollBarDirection.HORIZONTAL;
				_hScroll.x = margin - pointDiameter / 2;
				_hScroll.y = container.height - _hScroll.height - margin + 10;
				_hScroll.width = container.width - 2 * margin + pointDiameter;
				
				var range:Number = xTop - xBottom;
				
				_hScroll.setScrollProperties(range,xMin,xMax-range,range / 10);
				_hScroll.scrollPosition = xBottom;
				
				if(!_hScroll.hasEventListener(ScrollEvent.SCROLL)){
					_hScroll.addEventListener(ScrollEvent.SCROLL, handleScroll);
				}
								
				container.rawChildren.addChild(_hScroll);
			}
			
			protected var _scrollTimer:Timer;
			
			
			protected function handleScroll(se:ScrollEvent):void{	
				var range:Number = xTop - xBottom;
				_bitmap.x -= ((se.position - xBottom) * (container.width - 2 * margin) / range);  
				
				xBottom = Math.max(_hScroll.scrollPosition,xMin);
				xTop = Math.min(xBottom + range,xMax);
				
				if(_scrollTimer && _scrollTimer.running){
					_scrollTimer.reset();
					_scrollTimer.start();
				} 
				else{
					_scrollTimer = new Timer(300);
					_scrollTimer.addEventListener(TimerEvent.TIMER,function(e:Event):void{
							_scrollTimer.stop();
							refresh();
						});
					_scrollTimer.start();
				}
					
			}
			
			protected function zoomIn(midPointVal:Number=Number.POSITIVE_INFINITY):void{
				var zoomRange:Number = (xTop - xBottom) * zoomPercentage;
				var midPoint:Number = midPointVal != Number.POSITIVE_INFINITY ? midPointVal : xBottom + (xTop - xBottom) / 2;
				xBottom = Math.max(xMin,int(midPoint - zoomRange / 2));
				xTop = Math.min(xMax,int(midPoint + zoomRange / 2));
				refresh();
			}
			
			protected function zoomOut():void{
				var zoomRange:Number = (xTop - xBottom) / zoomPercentage;
				var midPoint:Number = xBottom + (xTop - xBottom) / 2;
				xBottom = Math.max(xMin,midPoint - zoomRange / 2);
				xTop = Math.min(xMax,midPoint + zoomRange / 2);
				refresh();
			}
			
			protected function dataToPosition(pointData:Object):Point{
				if(!(_dSetBounds[pointData.sourceURI] is Rectangle)) return null;
				var sBounds:Rectangle = _dSetBounds[pointData.sourceURI];
				
				return new Point((pointData[xDataField] - xBottom) * (sBounds.width - 2 * margin) /
						 	(xTop - xBottom) + sBounds.width / 2 + margin,
						 sBounds.height * (1 - (pointData[yDataField] - yMin) /
						 	(yMax - yMin)) + sBounds.y); 
			}
			
			
			//FIXME: Linear search here is probably going to cause performance problems sooner or later
			protected function xPosToDataPts(x:Number):Array{
				var overXPos:int = xPosToXVal(x);
				var pts:Array = []
				for each(var ds:AirQualityDataSet in _dataSets){
					for each (var dp:Object in ds.data){
						if(Math.abs(dp[xDataField] - overXPos) < 10){
							pts.push(dp);
							break;
						} 
					}					
				}
				return pts; 
			}
			
			protected function xPosToXVal(x:Number):int{
				var position:Number = x - margin;
				return xBottom + Math.floor(position * (xTop - xBottom)/(container.width - 2 * margin));
			}
			
			
			/****************************** Tooltipping Methods ************************************/
			protected var _plotTip:ToolTip;
			
			/**
			 * Draws and positions a tooltip for the given datapoint.
			 */
			public function drawDataTip(dataPoint:Object):void{
				
				var ptPosition:Point = dataToPosition(dataPoint);
				if(!ptPosition) return;
				ptPosition = container.localToGlobal(ptPosition);
				if(!_plotTip)_plotTip = ToolTipManager.createToolTip(dataPoint.value,ptPosition.x,ptPosition.y) as ToolTip;
			
				//color the tip and add additional text if possible
				if(dataPoint.value){
					//FIXME: Currently defaulting to pollutant from the first dataset, should be able to support per-track
					var cat:String = AirQualityColors.getAQICategoryForValue(dataSets[0].pollutant,dataPoint.value);
					var color:uint = AirQualityColors.getColorForAQICategory(cat);
					_plotTip.setStyle("backgroundColor",color);
					_plotTip.setStyle("backgroundAlpha",0.7);
					var time:Number = Number(dataPoint.time * 1000);
					var date:Date = new Date(time);
					_plotTip.text = (date + "\n" + 
						dataPoint.value + " (" + cat + ")" +
						((dataPoint.lat == null || dataPoint.lat == "None") ? "\n!NO GPS DATA" : ""));
					var rightInset:Number = Math.max(0, ptPosition.x + _bitmap.x -
						 container.localToGlobal(new Point(container.width - _plotTip.width)).x);
					_plotTip.x = ptPosition.x + _bitmap.x - rightInset;
					_plotTip.y = ptPosition.y;
					
					_plotTip.graphics.clear();
					
					//Overplot nearby points as part of the tooltip
					/*var pn:int = dataToPointNum(dataPoint);
					if(pn != -1){
						for(var pi:int = pn - numMouseOverAdjacents; pi < pn + numMouseOverAdjacents; pi++){
							if(pi < 0 || pi >= data.length) continue;
							var adjPt:Object = data[pi];
							if(adjPt && adjPt.lat != null && adjPt.lat !="None"){
								var aColor:uint = AirQualityColors.getColorForValue(dataSets[0].pollutant,adjPt.value);
								var aPosition:Point = container.localToGlobal(dataToPosition(adjPt));
								_plotTip.graphics.lineStyle(2,0xffffff,0.7);
								_plotTip.graphics.beginFill(aColor,1);
								_plotTip.graphics.drawCircle(aPosition.x - ptPosition.x, aPosition.y - ptPosition.y,pointDiameter - (pointDiameter/2 * Math.abs(pi - pn)/numMouseOverAdjacents));
				    			_plotTip.graphics.endFill();								
							}
						}
					}*/
					
					PointRenderer.drawPointToGraphics(_plotTip.graphics,dataPoint,new Point(),
						dataSets[0].pollutant,selections.isSelected(dataPoint),true,pointDiameter);
					//Plot an accentuated version of the point as part of the tooltip
					/*_plotTip.graphics.lineStyle(2,0xffffff,0.7);
					_plotTip.graphics.beginFill(color,1);
					_plotTip.graphics.drawCircle(rightInset,0,pointDiameter);
	    			_plotTip.graphics.endFill();
	    			_plotTip.graphics.beginFill(0xffffff,1);
	    			_plotTip.graphics.drawCircle(rightInset,0,pointDiameter/2);
	    			_plotTip.graphics.endFill();*/
	    			
				}
				else _plotTip.text = "No Data";
			}	
				
				
			public function discardActiveDataTip():void{
				if(_plotTip){
					ToolTipManager.destroyToolTip(_plotTip);
					_plotTip = null;
					dispatchEvent(new DataPointEvent(DataPointEvent.UNHOVER));
				}
			}
			
			protected function handleMouseClick(me:MouseEvent):void{
				//if we've clicked on some other child (like the scrollbar) do nothing
				if(me.target != container) return;
				
				//calculate the location of the click and locate the nearest matching point
				var overPts:Array = xPosToDataPts(me.localX);
							
				//If we have a point, fire an event
				if(overPts.length > 0) dispatchEvent(new DataPointEvent(DataPointEvent.CLICK,overPts[0],new Point(me.stageX,me.stageY)));
			}
			
			protected function handleDoubleClick(me:MouseEvent):void{
				//if we've clicked on some other child (like the scrollbar) do nothing
				if(me.target != container) return;
				
				//calculate the location of the click and locate the nearest matching point
				var xVal:int = xPosToXVal(me.localX);
							
				//If we have a point, zoom
				if(xVal > xBottom && xVal < xTop) zoomIn(xVal);
			}
			
			
			protected function handleMouseMove(me:MouseEvent):void{
				
				//if we've moused over some other child (like the scrollbar) do nothing
				if(me.target != container) return;
				
				//calculate the location we're currently mousing over and locate the nearest matching point
				var overPts:Array = xPosToDataPts(me.localX);
				
				
				//If we have a point, mark it
				if(overPts.length > 0){
					var overPt:Object = overPts[0];
					drawDataTip(overPt);
					tipLine.x = me.localX + container.x;
					tipLine.visible = true;
					dispatchEvent(new DataPointEvent(DataPointEvent.HOVER,overPt,new Point(me.stageX,me.stageY)));
				} 
				//If no points, throw away any tip we might have
				else{
					discardActiveDataTip();
					tipLine.visible = false;
				} 
				
			}
			
			protected function handleMouseOut(me:MouseEvent):void{
				tipLine.visible = false;
				discardActiveDataTip();
			}
			
			
			/****************************** Helper Methods ************************************/
			
			protected function calculateMinMax():void{
				
				xMin = yMin = xBottom = Number.POSITIVE_INFINITY; 
				xMax = yMax = xTop = Number.NEGATIVE_INFINITY;
				
				for each(var ds:AirQualityDataSet in dataSets){
					//Find mins and maxes
					for each(var o:Object in ds.data){

						var xVal:Number = Number(o[xDataField]);
						if(isNaN(xMin) || xVal < xMin) xMin = xVal;
						if(isNaN(xMax) || xVal > xMax) xMax = xVal;

						var yVal:Number = Number(o[yDataField]);
						if(isNaN(yMin) || yVal < yMin) yMin = yVal;
						if(isNaN(yMax) || yVal > yMax) yMax = yVal;
					}
				}
				xBottom = xMin;
				xTop = xMax;
			}
		]]>
	</mx:Script>
	
	
</mx:Canvas>
