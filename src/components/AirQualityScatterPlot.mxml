<?xml version="1.0" encoding="utf-8"?>
<mx:Canvas xmlns:mx="http://www.adobe.com/2006/mxml" xmlns:display="flash.display.*"  height="70"
	backgroundColor="0xDDCCCCCC" backgroundAlpha="0.8" 
	horizontalScrollPolicy="off" verticalScrollPolicy="off">
	
	<mx:VRule id="tipLine" top="{margin}" bottom="{margin}" visible="false"/>
	
	<mx:Canvas id="container" width="100%" height="100%" resize="{refresh()}" 
		mouseOver="{handleMouseMove(event)}" mouseOut="{handleMouseOut(event)}" 
		mouseMove="{handleMouseMove(event)}" click="{handleMouseClick(event)}" 
		doubleClick="{handleDoubleClick}"
		horizontalScrollPolicy="off" verticalScrollPolicy="off"
		doubleClickEnabled="true" 
		alpha="{plotCheck.selected ? 1 : 0.4}" enabled="{plotCheck.selected}"/>
	<mx:ProgressBar id="progressBar" mode="manual" minimum="0" verticalCenter="10" left="{margin}" right="{2 * margin}"/>
	
	<mx:CheckBox id="plotCheck" x="15" y="5" selected="true" visible="false"/>
	<mx:LinkButton id="remove" click="{dispatchEvent(new CSEvent(CSEvent.REMOVE_CLICKED))}" label="x" x="8" y="5" 
		enabled="{plotCheck.selected}" toolTip="remove track" />
	<mx:LinkButton id="zIn" click="{zoomIn()}" label="+" x="28" y="5" 
		enabled="{plotCheck.selected}" toolTip="zoom in" />
	<mx:LinkButton id="zOut" click="{zoomOut()}" label="-" left="50" top="5" 
		enabled="{plotCheck.selected}" toolTip="zoom out"/>
	<mx:Label text="{displayName}" left="75" fontFamily="Helvetica" color="#898989" fontSize="15" fontWeight="normal" top="5" selectable="true"/>
	
	<mx:Script>
		<![CDATA[
			import events.CSEvent;
			import etc.AirQualityColors;
			import events.DataPointEvent;
			import mx.controls.ToolTip;
			import mx.core.IToolTip;
			import mx.managers.ToolTipManager;
			import fl.events.ScrollEvent;
			import fl.controls.ScrollBarDirection;
			import fl.controls.ScrollBar;
			import __AS3__.vec.Vector;
			
			//------------- Public variables -----------------------------------------------
			[Bindable]
			public var displayName:String;
			public var xDataField:String = 'time';
			public var yDataField:String = 'value';
			public var pollutant:String = AirQualityColors.PM_25_24HR;
			public var margin:Number = 15;
			public var pointDiameter:Number = 6;
			public var pointOverlapTolerance:Number = 6;
			public var zoomPercentage:Number = 0.6;
			public var minPoints:uint = 100;
			
			override public function get data():Object{return _data;}
			override public function set data(d:Object):void{
				if(d is Vector.<Object>){ 
					_data = d as Vector.<Object>; plotData();
					
					//Find mins and maxes
					for each(var o:Object in data){

						var xVal:Number = Number(o[xDataField]);
						if(isNaN(xMin) || xVal < xMin) xMin = xVal;
						if(isNaN(xMax) || xVal > xMax) xMax = xVal;

						var yVal:Number = Number(o[yDataField]);
						if(isNaN(yMin) || yVal < yMin) yMin = yVal;
						if(isNaN(yMax) || yVal > yMax) yMax = yVal;
					}
					
					xBottom = xMin;
					xTop = xMax;
					
					if(isNaN(yMin) || isNaN(yMax)) return;
					
					refresh();
				}
				else if(d == null) return;
				else throw new ArgumentError("CommonSenseAirQualityPlot currently expects " + 
						"its data object to be of type Vector.<Object>");
			}
			
			//------------- Data Management variables -----------------------------------------------
			protected var _data:Vector.<Object>;
			//protected var fPoint:uint; 		//the index in _data of the lowest point currently displayed
			//protected var lPoint:uint;		//the index in _data of the highest point currently displayed
			protected var yMin:Number;		//the lowest data value on the y axis
			protected var yMax:Number; 		//the highest data value on the y axis
			protected var xMin:Number;		//the lowest data value on the x axis
			protected var xMax:Number;		//the lowest data value on the x axis
			
			protected var xBottom:Number;	//the bottom end of the current display x-axis
			protected var xTop:Number;		//the top end of the current display x-axis
			//protected function get xMin():Number { return _data[fPoint][xDataField];}	//lowest value on the x axis
			//protected function get xMax():Number { return _data[lPoint][xDataField];}	//highest value on the x axis
			
			protected var _bitmap:Bitmap;
			protected var _mask:Sprite = new Sprite();
			protected var _hScroll:ScrollBar = new ScrollBar();
						
			


		
			//-------------Public Methods -----------------------------------------------------

			public function refresh():void{
				plotData();
			}
			
			
			//------------- Protected Methods -----------------------------------------------------
				
			protected function plotData(e:Event=null):void{
				
				if(!container) return;

				//clear previously drawn bitmaps
				while(container.rawChildren.numChildren > 0)container.rawChildren.removeChildAt(0);

				//If no data do nothing
				if(!data || data.length == 0) return;
				
				
				//prep the shape object and bitmap data we'll use to draw the points
				var plotShape:Shape = new Shape();
				var translationMatrix:Matrix = new Matrix();
				var plotBitmapData:BitmapData = new BitmapData(container.width * 2,container.height,true,0x00FFFFFF);
											
				var prevPoint:Object;
				var prevPt:Point;
				
				//draw outside the current range so that scrolling 
				// cuts less abruptly
				var curRange:Number = xTop - xBottom;
				var xbd:Number = Math.max(xMin,xBottom - curRange);
				var xtd:Number = Math.min(xMax,xTop + curRange);
				
				plotBitmapData.lock();
				
				for(var i:int=0; i < data.length; i++){
					var point:Object = data[i]; 
					if(point.time < xbd || point.time > xtd) continue;
					if(!point.cat)point.cat = AirQualityColors.getAQICategoryForValue(pollutant,point.value);
				
					//determine location
					var dPt:Point = dataToPoint(data[i],i);
		
					//skip if position, category not different from last
					if(prevPoint && prevPoint.cat == point.cat 
							&& Math.abs(prevPt.x - dPt.x) < pointOverlapTolerance 
							&& Math.abs(prevPt.y - dPt.y) < pointOverlapTolerance){
						continue;
					}  
									
					//draw the point
					var color:uint = AirQualityColors.getColorForValue(pollutant,point.value);
					plotShape.graphics.clear();
					plotShape.graphics.lineStyle(0.5,0xffffff,0.6);
					plotShape.graphics.beginFill(color,0.6);
					plotShape.graphics.drawCircle(0,0,pointDiameter/2);
        			plotShape.graphics.endFill();
					translationMatrix.tx = dPt.x;
					translationMatrix.ty = dPt.y;
					
					plotBitmapData.draw(plotShape,translationMatrix);
										
					prevPoint = point;
					prevPt = dPt;
				}
				
				plotBitmapData.unlock();
				
				_bitmap = new Bitmap(plotBitmapData);
				_bitmap.x = -(container.width / 2);
				
				container.rawChildren.addChild(_bitmap);
				
				//draw and position the scrollBar and mask
				setupMask();
				setupScrollBar();
			}
		

			/**
			 * Setup and place the mask for the bitmap 
			 */ 
			protected function setupMask():void{
				_mask.graphics.clear();
				_mask.graphics.beginFill(0xFFFFFF);
				_mask.graphics.drawRect(margin - pointDiameter / 2,margin - pointDiameter / 2,
					container.width - 2 * margin + pointDiameter, container.height - margin);
				_mask.graphics.endFill();
				
				container.rawChildren.addChild(_mask);
				
				if(container.mask != _mask)container.mask = _mask;
			}
			
			
			/**
			 * Set up and place the scroll bar
			 */
			protected function setupScrollBar():void{
				_hScroll.direction = ScrollBarDirection.HORIZONTAL;
				_hScroll.x = margin - pointDiameter / 2;
				_hScroll.y = container.height - _hScroll.height - margin + 10;
				_hScroll.width = container.width - 2 * margin + pointDiameter;
				
				var range:Number = xTop - xBottom;
				
				_hScroll.setScrollProperties(range,xMin,xMax-range,range / 10);
				_hScroll.scrollPosition = xBottom;
				
				if(!_hScroll.hasEventListener(ScrollEvent.SCROLL)){
					_hScroll.addEventListener(ScrollEvent.SCROLL, handleScroll);
				}
								
				container.rawChildren.addChild(_hScroll);
			}
			
			protected var _scrollTimer:Timer;
			
			
			protected function handleScroll(se:ScrollEvent):void{	
				var range:Number = xTop - xBottom;
				_bitmap.x -= ((se.position - xBottom) * (container.width - 2 * margin) / range);  
				
				xBottom = Math.max(_hScroll.scrollPosition,xMin);
				xTop = Math.min(xBottom + range,xMax);
				
				if(_scrollTimer && _scrollTimer.running){
					_scrollTimer.reset();
					_scrollTimer.start();
				} 
				else{
					_scrollTimer = new Timer(300);
					_scrollTimer.addEventListener(TimerEvent.TIMER,function(e:Event):void{
							_scrollTimer.stop();
							refresh();
						});
					_scrollTimer.start();
				}
					
			}
			
			protected function zoomIn():void{
				var zoomRange:Number = (xTop - xBottom) * zoomPercentage;
				var midPoint:Number = xBottom + (xTop - xBottom) / 2;
				xBottom = Math.max(xMin,int(midPoint - zoomRange / 2));
				xTop = Math.min(xMax,int(midPoint + zoomRange / 2));
				refresh();
			}
			
			protected function zoomOut():void{
				var zoomRange:Number = (xTop - xBottom) / zoomPercentage;
				var midPoint:Number = xBottom + (xTop - xBottom) / 2;
				xBottom = Math.max(xMin,midPoint - zoomRange / 2);
				xTop = Math.min(xMax,midPoint + zoomRange / 2);
				refresh();
			}
			
			protected function dataToPoint(pointData:Object,pointNum:int=-1):Point{
				if(pointNum == -1) pointNum = (_data as Vector.<Object>).lastIndexOf(pointData);
				if(pointNum == -1) return null;
				else return new Point((pointData[xDataField] - xBottom) * (container.width - 2 * margin) /
						 	(xTop - xBottom) + container.width / 2 + margin,
						 (container.height - 2 * margin - 10) * (1 - (pointData[yDataField] - yMin) /
						 	(yMax - yMin)) + margin); 
			}
			
			//TODO: Use a smarter (not O(n)) mechanism for these searches
			protected function xPosToPtNum(x:Number):int{
				var position:Number = x - margin;
				var overXPos:int = xBottom + Math.floor(position * (xTop - xBottom)/(container.width - 2 * margin));
				overXPos = Math.max(Math.min(overXPos,xMax),xMin);
				
				for(var i:int=0;i<_data.length; i++){
					if(Math.abs(_data[i][xDataField] - overXPos) < 10) return i;
				}
				return -1;
			}
			
			protected function xPosToData(x:Number):Object{
				var ptNum:int = xPosToPtNum(x); 
				if(ptNum > 0) return _data[ptNum];
				else return null;
			}
			
			/****************************** Tooltipping Methods ************************************/
			protected var _plotTip:ToolTip;
			
			/**
			 * Draws and positions a tooltip for the given datapoint.
			 */
			public function drawDataTip(dataPoint:Object):void{
				
				var ptPosition:Point = dataToPoint(dataPoint);
				if(!ptPosition) return;
				ptPosition = container.localToGlobal(ptPosition);
				if(!_plotTip)_plotTip = ToolTipManager.createToolTip(dataPoint.value,ptPosition.x,ptPosition.y) as ToolTip;
			
				//color the tip and add additional text if possible
				if(dataPoint.value){
					var cat:String = AirQualityColors.getAQICategoryForValue(pollutant,dataPoint.value);
					var color:uint = AirQualityColors.getColorForAQICategory(cat);
					_plotTip.setStyle("backgroundColor",color);
					_plotTip.setStyle("backgroundAlpha",0.7);
					var time:Number = Number(dataPoint.time * 1000);
					var date:Date = new Date(time);
					_plotTip.text = date + "\n" + dataPoint.value + " (" + cat + ")";
					var rightInset:Number = Math.max(0, ptPosition.x + _bitmap.x -
						 container.localToGlobal(new Point(container.width - _plotTip.width)).x);
					_plotTip.x = ptPosition.x + _bitmap.x - rightInset;
					_plotTip.y = ptPosition.y;
					
					//Plot an accentuated version of the point as part of the tooltip
					_plotTip.graphics.clear();
					_plotTip.graphics.lineStyle(2,0xffffff,0.7);
					_plotTip.graphics.beginFill(color,1);
					_plotTip.graphics.drawCircle(rightInset,0,(2/3)*pointDiameter);
	    			_plotTip.graphics.endFill();
	    			_plotTip.graphics.beginFill(0xffffff,1);
	    			_plotTip.graphics.drawCircle(rightInset,0,pointDiameter/3);
	    			_plotTip.graphics.endFill();
				}
				else _plotTip.text = "No Data";
			}	
				
				
			public function discardActiveDataTip():void{
				if(_plotTip){
					ToolTipManager.destroyToolTip(_plotTip);
					_plotTip = null;
					dispatchEvent(new DataPointEvent(DataPointEvent.UNHOVER));
				}
			}
			
			protected function handleMouseClick(me:MouseEvent):void{
				//if we've clicked on some other child (like the scrollbar) do nothing
				if(me.target != container) return;
				
				//calculate the location of the click and locate the nearest matching point
				var overPt:Object = xPosToData(me.localX);
							
				//If we have a point, fire an event
				if(overPt) dispatchEvent(new DataPointEvent(DataPointEvent.CLICK,overPt));
			}
			
			protected function handleDoubleClick(me:MouseEvent):void{
				
				//if we've clicked on some other child (like the scrollbar) do nothing
				if(me.target != container) return;
				
				//calculate the location of the click and locate the nearest matching point
				var overPt:Object = xPosToData(me.localX);
							
				//If we have a point, fire an event
				if(overPt) zoomIn();
			}
			
			
			protected function handleMouseMove(me:MouseEvent):void{
				
				//if we've moused over some other child (like the scrollbar) do nothing
				if(me.target != container) return;
				
				//calculate the location we're currently mousing over and locate the nearest matching point
				var overPt:Object = xPosToData(me.localX);
				
				
				//If we have a point, mark it
				if(overPt){
					drawDataTip(overPt);
					tipLine.x = me.localX;
					tipLine.visible = true;
					dispatchEvent(new DataPointEvent(DataPointEvent.HOVER,overPt));
				} 
				//If no points, throw away any tip we might have
				else{
					discardActiveDataTip();
					tipLine.visible = false;
				} 
				
			}
			
			protected function handleMouseOut(me:MouseEvent):void{
				tipLine.visible = false;
				discardActiveDataTip();
			}
			
			
			
		]]>
	</mx:Script>
	
	
</mx:Canvas>
