<?xml version="1.0" encoding="utf-8"?>
<mx:Application xmlns:mx="http://www.adobe.com/2006/mxml" layout="absolute" 
	xmlns:flex="com.modestmaps.flex.*" xmlns:flexlib="http://code.google.com/p/flexlib/" 
	implements="commentspace.IStatefulVis" 
	horizontalScrollPolicy="off" verticalScrollPolicy="off" xmlns:ns1="components.*"
	xmlns="*"
	backgroundGradientAlphas="[1.0, 1.0]" backgroundGradientColors="[#FFFFFF, #FFFFFF]" >
	
	
	<mx:Canvas id="container" width="100%" height="100%" backgroundColor="0xffffff" 
		horizontalScrollPolicy="off" verticalScrollPolicy="auto" creationComplete="{setup()}"/>
	
	<!--<mx:VDividedBox left="15" top="15" right="15" width="100" height="100%">
		<mx:VBox width="100%">
			<mx:HBox width="100%">
				<mx:Button label="+ load additional data" click="{triggerLoadingPopup()}"  
					height="25"/>
				<mx:Button label="refresh" click="{reloadDataSets()}"  
					toolTip="reloads all loaded datasets a any new data"
					height="25"/>
				<mx:Button label="center map on last point" click="{centermap()}"  
					color="#62D000" fillAlphas="[1.0, 1.0]" fillColors="[#FFFFFF, #E6E6E6]"
					height="25"/>	
			</mx:HBox>
			
		</mx:VBox>
	</mx:VDividedBox>-->
	
	<mx:VBox right="15" top="0" bottom="270" width="0" id="timelinesHolder"
	backgroundColor="#FFFFFF" backgroundAlpha="0" verticalGap="0"/>
		
	<mx:HBox width="100%">
	<flexlib:WindowShade paddingBottom="15" paddingLeft="15" id="badgeSelector" label="Shift" width="355" styleName="windowShadeStyle" creationComplete="{}">
		<flexlib:headerRenderer>
			<mx:Component>
				<mx:LinkButton cornerRadius="10" fontSize="15" fontFamily="Verdana" color="#73C400"/>
			</mx:Component>
		</flexlib:headerRenderer>
		<mx:Text text="select a pollutant" fontWeight="normal" fontSize="9" />
		<!--<mx:List dataProvider="{BADGES}" id="badgeIdList" 
			labelField="name" width="230" height="90" allowMultipleSelection="true" />-->
		<!--<mx:List dataProvider="{POLLUTANTS}" id="pollutantList"
			labelField="pollutant" height="90" selectedIndex="0"  width="230" itemClick="{fileBadgeListHandler()}" />-->
		
		<mx:RadioButtonGroup id="pollutantRadioGroup" itemClick="{fileBadgeListHandler()}" />
		<mx:Repeater id="pollutantRepeater" dataProvider="{POLLUTANTS}">
			<mx:RadioButton label="{pollutantRepeater.currentItem.pollutant}" visible="{pollutantRepeater.currentItem.abbreviation == 'co' ? false : true}" groupName="pollutantRadioGroup" value="{pollutantRepeater.currentItem}" />
		</mx:Repeater>
		
		<mx:Text text="file/badge listing for selected pollutant" fontWeight="normal" fontSize="9" />
		<mx:List dataProvider="{FILES}" id="fileBadgeList" allowMultipleSelection="true"
			labelField="name" height="115" width="330" selectedIndex="0" />
		
		<mx:Button label="Load/refresh" click="{selectorHandler(false)}"  
			toolTip="reloads all loaded datasets or loads any new data"
			height="25" />
	</flexlib:WindowShade>
	
	<flexlib:WindowShade paddingBottom="15" paddingLeft="15" id="episodesSelector" label="Air Quality" 
		x="{badgeSelector.width + locationSelector.width + timeSelector.width}" width="250" styleName="windowShadeStyle" opened="true">
		<flexlib:headerRenderer>
			<mx:Component>
				<mx:LinkButton cornerRadius="10" fontSize="15" fontFamily="Verdana" color="#73C400"/>
			</mx:Component>
		</flexlib:headerRenderer>
		<mx:Text text="select a reading range" fontWeight="normal" fontSize="9" />
		
		<!--<mx:HSlider id="airQualitySlider" width ="200" thumbCount="2" minimum="0" maximum="1" change="{airQualitySliderHandler()}" />-->
		<mx:CheckBox id="goodBox" label="Good" click="{airQualitySliderHandler()}" fillColors="{[AirQualityColors.GOOD_COLOR, AirQualityColors.GOOD_COLOR]}" />
		<mx:CheckBox id="moderateBox" label="Moderate" click="{airQualitySliderHandler()}" fillColors="{[AirQualityColors.MODERATE_COLOR, AirQualityColors.MODERATE_COLOR]}" />
		<mx:CheckBox id="unhealthySensitiveBox" label="Unhealthy for Sensitive Groups" click="{airQualitySliderHandler()}" fillColors="{[AirQualityColors.UNHEALTHY_SENSITIVE_COLOR, AirQualityColors.UNHEALTHY_SENSITIVE_COLOR]}" />
		<mx:CheckBox id="unhealthyBox" label="Unhealthy" click="{airQualitySliderHandler()}" fillColors="{[AirQualityColors.UNHEALTHY_COLOR, AirQualityColors.UNHEALTHY_COLOR]}" />
		<mx:CheckBox id="veryUnhealthyBox" label="Very Unhealthy" click="{airQualitySliderHandler()}" iconColor="0xFFFFFF" fillColors="{[AirQualityColors.VERY_UNHEALTHY_COLOR, AirQualityColors.VERY_UNHEALTHY_COLOR]}" />
		<mx:CheckBox id="hazardousBox" label="Hazardous" click="{airQualitySliderHandler()}" iconColor="0xFFFFFF" fillColors="{[AirQualityColors.HAZARDOUS_COLOR, AirQualityColors.HAZARDOUS_COLOR]}" />
		
		<mx:Button label="mark the 10 highest" click="{episodesHandler()}" visible="false"/>
		<!--<mx:Button label="remove episodes view" click="{destroyEpisodes()}" />-->
			
		<!--<mx:Text text="set the time window for an episode" />
		<mx:TextInput id="timeWindow" text="60" change="{Stats.TIME_WINDOW = Number(timeWindow.text); trace('timewindow changed to' + Number(timeWindow.text));}" />
		<mx:Text text="set the staggering for each window:" />
		<mx:TextInput id="windowStaggering" text="30" change="{Stats.WINDOW_STAGGERING = Number(windowStaggering.text); trace('stagger changed' + Number(windowStaggering.text));}" />-->
		
	</flexlib:WindowShade>
	
	<mx:Button toolTip="close all menus" top="5" height="28" cornerRadius="10" x="{badgeSelector.width + episodesSelector.width}" id="shadeCloser" label="▲" click="{closeAllShades()}" />
	<!--<mx:Button toolTip="opens a new instance of this visualization" top="5" height="28" cornerRadius="10" x="{badgeSelector.width + episodesSelector.width + shadeCloser.width}" id="newInstanceOpener" label="New Instance" click="{openNewInstance()}" />-->
	
	<flexlib:WindowShade paddingBottom="15" paddingLeft="15" id="locationSelector" label="Location" visible = "false"
		x="{badgeSelector.width}" width="250" styleName="windowShadeStyle" opened="false">
		<flexlib:headerRenderer>
			<mx:Component>
				<mx:LinkButton cornerRadius="10" fontSize="15" fontFamily="Verdana" color="#73C400"/>
			</mx:Component>
		</flexlib:headerRenderer>
		<mx:Text text="see data at a location" fontWeight="normal" fontSize="9" />
		<mx:TextInput id="location" text="18th and Telegraph, Oakland, CA"/>
		<mx:Button label="Go" click="{locationHandler()}" />
	</flexlib:WindowShade>
	
	<flexlib:WindowShade paddingBottom="15" paddingLeft="15" id="timeSelector" label="Time" opened="false" visible = "false"
		x="{badgeSelector.width + locationSelector.width}" width="220" styleName="windowShadeStyle">
		<flexlib:headerRenderer>
			<mx:Component>
				<mx:LinkButton cornerRadius="10" fontSize="15" fontFamily="Verdana" color="#73C400"/>
			</mx:Component>
		</flexlib:headerRenderer>
		<mx:Text text="select a time range" fontWeight="normal" fontSize="9" />
		<mx:DateChooser id="dateChooser" borderColor="#FFFFFF" selectedDate="{new Date()}"
			allowMultipleSelection="true" allowDisjointSelection="false" showToday="false" width="180"/>
		<mx:Button label="show these dates" click="{selectorHandler(false)}" />
		
		<!--<mx:Button label="Show all times" click="{selectorHandler()}" />-->
	</flexlib:WindowShade>
	
	</mx:HBox>
	
	<mx:VDividedBox left="15" bottom="15" right="15" width="100" height="100%" dividerRelease="{adjustMapControlsPosition()}">
		<mx:HBox id="controlsHBox" verticalAlign="bottom" horizontalAlign="left" height="75%" width="100%">
			<mx:VBox id="playButtonBox" visible="false" backgroundColor="#FFFFFF" borderStyle="solid" borderColor="#9D9D9D" width="195" paddingBottom="5" paddingLeft="5" paddingRight="5" paddingTop="5" cornerRadius="10" horizontalAlign="center" verticalGap="0">
				<mx:HBox>
					<mx:VBox cornerRadius="15" width="115" verticalGap="2">
						<mx:Label text="{timeline &amp;&amp; timeline.playheadDate ? timeline.playheadDate.toLocaleTimeString() : ''}" styleName="csH1" fontSize="18" fontWeight="bold" textAlign="right" width="114"/>
						<mx:Label text="{timeline &amp;&amp; timeline.playheadDate ? timeline.playheadDate.toLocaleDateString() : ''}" styleName="csH1" fontSize="13" width="114" textAlign="right"/>
					</mx:VBox>
					<mx:Button label="{timeline._playing ? '||' : '▶'}" cornerRadius="10"
						toolTip="{timeline._playing ? 'pause' : 'play'}" height="100%" fontSize="23" id="bigPlayPause" 
						click="{timeline._playing ? timeline.stopPlayback(event) : timeline.startPlayback(event)}" width="55"/>
				</mx:HBox>
				<mx:HBox horizontalAlign="center" verticalAlign="middle" horizontalGap="0">
					<mx:Label text="slow" fontSize="9" paddingTop="4"/>
					<mx:HSlider id="playSlider" x="{timeline.margin}" height="18" value="{Math.log(timeline.timeMultiplier)*Math.LOG10E}" width="100"
						minimum="0.3" maximum="4" dataTipFormatFunction="{playScrollDataTip}"
						toolTip="{'playback speed: ' + int(Math.pow(10,playSlider.value)) + 'x'}" liveDragging="true"
						change="{timeline.timeMultiplier=Math.pow(10,playSlider.value)}" visible="{!timeline.noControls}"/>
					<mx:Label text="fast" fontSize="9" paddingTop="4"/>
				</mx:HBox>
			</mx:VBox>
			<mx:Canvas width="{timeline.width - 330}">
				<mx:ProgressBar id="progressBar" width="100%" visible="false" includeInLayout="false" indeterminate="true" mode="manual"/>
			</mx:Canvas>
			<mx:Canvas id="controlsCanvas"/>
		</mx:HBox>
		<ns1:AirQualityTimeLine id="timeline" width="100%" height="200" left="15" right="15" bottom="15" creationComplete="{setup()}"/>
	</mx:VDividedBox>
	
	<!--<ns1:AirQualityLegend id="legend" bottom="220" right="15" width="650" height="30"/>-->
	

	<mx:Script>
		<![CDATA[
			import etc.AirQualityColors;
			import mx.core.UIComponent;
			import components.IconControls;
			import mx.controls.LinkButton;
			import com.adobe.serialization.json.JSON;
			import commentspace.events.EntityEvent;
			import mx.events.CollectionEventKind;
			import mx.events.CollectionEvent;
			import events.TimelineEvent;
			import events.DataSetEvent;
			import data.SelectionSet;
			import data.AirQualityDataSet;
			import __AS3__.vec.Vector;
			import components.DisclaimerPanel;
			import components.InputErrorPanel;
			import events.CSEvent;
			import events.DataPointEvent;
			import mx.managers.PopUpManager;
			import components.loading.DataLoadingPanel;
			import components.AirQualityMapLayer;
			import etc.AirQualityConstants;
			import mx.messaging.AbstractConsumer;
			import mx.effects.Zoom;
			import com.modestmaps.mapproviders.microsoft.MicrosoftHybridMapProvider;
			import com.modestmaps.events.MarkerEvent;
			import com.modestmaps.TweenMap;
			import com.modestmaps.extras.ui.Button;
			import mx.events.ResizeEvent;
			import com.modestmaps.events.MapEvent;
			import commentspace.StatefulVisEvent;
			import com.modestmaps.overlays.MarkerClip;
			import mx.events.MenuEvent;
			import mx.controls.Menu;
			import com.modestmaps.Map;
			import com.modestmaps.extras.ZoomSlider;
			import com.modestmaps.extras.MapControls;
			import flash.sampler.Sample;
			import com.modestmaps.geo.Location;
			import mx.events.FlexEvent;
			import mx.controls.Label;
			import data.Stats;
			
			/******** Embedded Assets **********************************************************/
			[Embed(source="assets/flag_blue.png")]
			protected const BlueFlagIcon:Class;
			[Embed(source="/assets/comment_flag.png")]
			protected const CommentIcon:Class;
			[Embed(source="assets/cross.png")]
			protected const CancelIcon:Class;
			
			
			
			/******** Constants **********************************************************/
			protected const CLICK_RADIUS:Number = 2;
			
			protected static const DESATURATION_MATRIX:Array = [
					0.3, 0.59, 0.3, 0, 0,
		            0.3, 0.59, 0.3, 0, 0,
		            0.3, 0.59, 0.3, 0, 0,
		            0, 0, 0, 0.5, 0
		        ];
		    
		    // Adding Google API key to enable geocoding (note security restriction stuff associated with this)...
		    // Use this key for testing locally 
		    //public static const GOOGLE_API_KEY:String = "ABQIAAAA_3td1tmQ7cbEqh_kQLucMRRl_cuzxjTWTH-RUAWem_qXsJGROBTgOLdo3jwgLuyWZ63_ndi7h3-PQg";
		    // Use this key for hosting on commonsensecommunity.com
		    public static const GOOGLE_API_KEY:String = "ABQIAAAA_3td1tmQ7cbEqh_kQLucMRQXZpYdCZCcWeB4L1TxFQtaTFEDDxSqPJc0whJ2_2BTJeTgn0uDSRY4tA";
		    
			protected const BADGES:Array = [
				{name:"Badge 1",id:'000000000001'},
				{name:"Badge 2",id:'000000000002'},
				{name:"Badge 3",id:'000000000003'},
				{name:"Badge 4",id:'000000000004'},
				{name:"Badge 5",id:'000000000005'},
				{name:"Badge 6",id:'000000000006'},
				{name:"Badge 7",id:'000000000007'},
				{name:"Badge 8",id:'000000000008'},
				{name:"Badge 9",id:'000000000009'},
				{name:"Badge 10",id:'00000000000A'},
				{name:"Badge 11",id:'00000000000B'},
				{name:"Badge 12",id:'00000000000C'},
				{name:"Badge 13",id:'00000000000D'},
				{name:"Badge 14",id:'00000000000E'},
				{name:"Badge 15",id:'00000000000F'},
				{name:"Badge 16",id:'000000000010'},
				{name:"Badge 17",id:'000000000011'},
				{name:"Badge 18",id:'000000000012'},
				{name:"Badge 19",id:'000000000013'},
				{name:"Badge 20",id:'000000000014'},
				{name:"Badge 21",id:'000000000015'},
				{name:"Badge 22",id:'000000000016'}];
				
			protected const POLLUTANTS:Array = [
				{pollutant:"Carbon Monoxide (8-hour thresholds)",abbreviation:"co",db:'mco',multiplier:0.001},
				{pollutant:"Particulate Matter (24-hour thresholds)",abbreviation:"pm",db:"pm",multiplier:1000}
				//{pollutant:"Particulate Matter 2.5 (24-hour thresholds)",abbreviation:"pm25",db:"pm25",multiplier:1000},
				//{pollutant:"Particulate Matter 10 (24-hour thresholds)",abbreviation:"pm10",db:"pm10",multiplier:1000},
				//{pollutant:"Ozone (1-hour thresholds)",abbreviation:"ozone8",db:'so3',multiplier:0.001},
				//{pollutant:"Ozone (8-hour thresholds)",abbreviation:"ozone1",db:'o3',multiplier:0.001},
				//{pollutant:"Sulfur Dioxide (24-hour thresholds)",abbreviation:"so2",db:'so2',multiplier:0.001}
				];
			
			protected var FILES:Array = [];
				
			public static const BASE_DB_QUERY_URL:String = "http://www.commonsensecommunity.com/badgedata/"; 	//production server
			public static const BASE_SHIFT_QUERY_URL:String = "http://www.commonsensecommunity.com/shiftQuery/";
			public static const BASE_PM_QUERY_URL:String = "http://www.commonsensecommunity.com/pmQuery/";
			//public static const BASE_DB_QUERY_URL:String = "http://12.46.129.13:8080/badgedata/"; 				//development server
			public static const PM_DATA_DIR:String = "http://www.commonsensecommunity.com/data/WestOaklandPM";
			//public static const PM_DATA_DIR:String = "http://www.eecs.berkeley.edu/~willettw/temp/WestOaklandPM/";
		
			
			/******** Local Vars **********************************************************/
			protected var maxPoints:int = 1000;
			
			//the map!
			protected var map:TweenMap;
			
			//the controls for the map!
			protected var controls:IconControls;
			
			//Clip the flags are drawn into
			protected var _flagsClip:MarkerClip;
			
			//Clip the textures are drawn into
			protected var _plotLayer:AirQualityMapLayer;
			
			//The backing data sets for the visualization
			protected var _dataSets:Vector.<AirQualityDataSet> = new Vector.<AirQualityDataSet>();
			
			//An object containing a list of selections 
			protected var _selections:SelectionSet = new SelectionSet();
			
			//flag to prevent updated events from being dispatched during panAndZoomTo runs
			protected var _isPanningAndZooming:Boolean = false; 
			
			protected var firstLoad:Boolean = false;
			protected function setup():void{
				// Force select and load pm shift list by default
				pollutantRadioGroup.getRadioButtonAt(1).selected = true;
				fileBadgeListHandler();
				
				if(!firstLoad) firstLoad = true;
				else{
					setupMap();
					setupTimeline();
				}
			}
			
			/**
			 * Datatip function for playhead speed slider.
			 */
			protected function playScrollDataTip(val:Number):String{
				return int(Math.pow(10,val)) + 'x';
			}
			
			/**
			 * Adjusts the position of map control sprite when we change the VDividedBox
			 */
			protected function adjustMapControlsPosition():void{
//				trace("timeline height now = "+timeline.height);
//				controls.fullScreenButton.visible = true;
//				controls.x = container.width - 100;
//				controls.y = -controlsHBox.height + 400;
			}
			
			/******** Mapping Methods **********************************************************/
			protected function setupMap():void{
				
				map = new TweenMap();
				map.setMapProvider(new MicrosoftHybridMapProvider(10,19));
				map.grid.filters = [new ColorMatrixFilter(DESATURATION_MATRIX)];
				container.rawChildren.addChild(map);
				
				map.x = 0;
				map.y = 0;
				map.setSize(container.width,container.height);
				
				map.panDuration = 0.6;
				map.zoomDuration = 0.5;
				map.panAndZoomDuration = 0.6;
				map.useHandCursor = map.buttonMode = true;
				
				_plotLayer = new AirQualityMapLayer(map);
				_plotLayer.dataSets = _dataSets;
				_plotLayer.selections = _selections;
				
				map.addChild(_plotLayer);
				
				// add the controls to the map
				controls = new IconControls(map);
//				map.addChild(controls);
//				trace("coordinates of controls: "+controls.x+","+controls.y);
//				controls.x = timeline.width;
//				controls.y = timeline.height;
				
				// try putting the map controls in a UIComponent then adding it the HBox...
				var uicomp:UIComponent = new UIComponent();
				controlsCanvas.addChild(uicomp);
				uicomp.addChild(controls);
				//controls.x += 35;
				controls.y -= 55;
				trace("coordinates of controls: "+controls.x+","+controls.y);
				
				//set the map center
				map.setCenterZoom(new Location(37.803,-122.298),14);
				
				//Listeners for updating state 
				map.addEventListener(MapEvent.STOP_PANNING, dispatchUpdated);
				map.addEventListener(MapEvent.STOP_ZOOMING, dispatchUpdated);
				map.addEventListener(CSEvent.PAN_AND_ZOOM_COMPLETE, dispatchUpdated);
				
				this.addEventListener(ResizeEvent.RESIZE,onResize);
				
				//Listener for zoom and pan
				map.addEventListener(MouseEvent.DOUBLE_CLICK,function(me:MouseEvent):void{
						var location:Location = map.pointLocation(map.globalToLocal(new Point(me.stageX,me.stageY)),map);
						panAndZoomTo(location,map.getZoom() + 1);
					});
				
				//A function for loading a default set of data		
				//TODO: make this cleaner
				var runOnStartup:Function = function():void{
					var request:URLRequest = new URLRequest(DataLoadingPanel.DATA_INDEX_XML_URL);
					var loader:URLLoader = new URLLoader(request);
					
					loader.addEventListener(Event.COMPLETE,function(e:Event):void{
							var indexString:String = loader.data;
							indexString = indexString.replace(/BASE_DB_QUERY_URL/gi,DataLoadingPanel.BASE_DB_QUERY_URL);
							indexString = indexString.replace('24HOURSAGO',int((new Date().time) / 1000 - 24 * 3600));
							indexString = indexString.replace('1WEEKAGO',int((new Date().time) / 1000 - 7 * 24 * 3600));
							var indexArray:Array = JSON.decode(indexString).defaults as Array;
							
							if(indexArray && indexArray.length > 0){
								var loading:int = indexArray.length;
								for each(var def:Object in indexArray){
									loadData(def.url,def.reading,def.name,function():void{ 
										loading--;
										if(loading == 0)dispatchComplete(); 
									});	
								}	
							}
						});
					};	
					
				var quickStartup:Function = function ():void{
					var quickdata:Object = {"name":"All Badges Carbon Monoxide (past 3 hours)",
						"url":DataLoadingPanel.BASE_DB_QUERY_URL +"?reading=mco&start_time=" + int((new Date().time) / 1000 - 3 * 3600),
						"reading":"co"};
					loadData(quickdata.url,quickdata.reading,quickdata.name,function():void{centermap();dispatchComplete();});
				}
				
				
				/*A set of different options for what to do on startup. 1-4 are helpful when debugging*/
					
				//0.Production startup. Requires a click-through disclaimer before using the site	
				//triggerDisclaimerPopup(runOnStartup);
				
				//1.Alternative startup. Jump straight into a load
				//runOnStartup();
				
				//2.Alternative startup, loads a small test dataset
				//quickStartup();
					
				//3.Alternative startup, just pops up the loader
				//triggerLoadingPopup();
				
				//4. Do nothing. Just let commentspace know we're loaded
				dispatchComplete();	
					
			}
			
			protected function setupTimeline():void{

				timeline.dataSets = _dataSets;
				timeline.selections = _selections;
				
				//Add handlers for linked tooltipping between map and timeline
				var drawMapTip:Function = function(de:DataPointEvent=null):void{
						_plotLayer.drawDataTip(de.dataPoint);
					};
				var drawTimelineTip:Function = function(de:DataPointEvent=null):void{
						timeline.drawDataTip(de.dataPoint);
					};
				var discardMapTip:Function = function(de:DataPointEvent=null):void{
						_plotLayer.discardActiveDataTip();
					};
				var discardTimelineTip:Function = function(de:DataPointEvent=null):void{
						timeline.discardActiveDataTip();
					};
				timeline.addEventListener(DataPointEvent.HOVER,drawMapTip);
				timeline.addEventListener(DataPointEvent.UNHOVER,discardMapTip);
				_plotLayer.addEventListener(DataPointEvent.HOVER,drawTimelineTip);
				_plotLayer.addEventListener(DataPointEvent.UNHOVER,discardTimelineTip);
				
				//handlers for popup menus on map and timeline
				timeline.addEventListener(DataPointEvent.CLICK,function(de:DataPointEvent):void{
						discardTimelineTip();	
						createMenu(de.mousePosition,de.dataPoint);
						
					});
				_plotLayer.addEventListener(DataPointEvent.CLICK,function(de:DataPointEvent):void{
						discardMapTip();
						createMenu(de.mousePosition,de.dataPoint);
					});
				
				//handlers for dataset removal and hide/unhide
				var handleRemove:Function = function(de:DataSetEvent):void{
						_plotLayer.refresh(true);
						timeline.refresh(true);
						
						if(timelinesHolder.numChildren > 0){ // FIXME really hacky way of removing the episodesview when the corr. dataset removed
							var i:Number = 0;
							/*
							while(!(timelinesHolder.getChildAt(i) is AirQualityTimeLine)){
								i++;
							}
							var firstTimeLine:AirQualityTimeLine = (timelinesHolder.getChildAt(i) as AirQualityTimeLine);
							trace("timeline = " + firstTimeLine.xDataField);
							trace("removing: " + (firstTimeLine.dataSets[0] as AirQualityDataSet).name);
							if((firstTimeLine.dataSets[0] as AirQualityDataSet).name  == de.dataset.name){
								destroyEpisodes();
							}
							*/
							destroyEpisodes();
						}
						
						dispatchUpdated();
					};
				var handleHide:Function = function(de:DataSetEvent):void{			
						timeline.refresh(true);
						_plotLayer.refresh(true);
						dispatchUpdated();
					};
				timeline.addEventListener(DataSetEvent.DATASET_REMOVED, handleRemove);
				timeline.addEventListener(DataSetEvent.DATASET_HIDDEN, handleHide);
				timeline.addEventListener(DataSetEvent.DATASET_UNHIDDEN, handleHide);
					
				//time scrubbing for map
				timeline.addEventListener(TimelineEvent.PLAYHEAD_MOVED,function(te:TimelineEvent):void{
						if(te.playheadTime){
							_plotLayer.maxTime = te.playheadTime;
							_plotLayer.refresh();
						} 
					});
				
				//Listener for updating map min and max times on the map when timeline zooms and pans
				var timelineMoveHandler:Function = function(te:TimelineEvent):void{
						if(!isNaN(timeline.xTop)) _plotLayer.maxTime = timeline.xTop;
						if(!isNaN(timeline.xBottom)) _plotLayer.minTime = timeline.xBottom;
						_plotLayer.refresh();
						dispatchUpdated();
					};
				timeline.addEventListener(TimelineEvent.TIMELINE_ZOOMED,timelineMoveHandler);
				timeline.addEventListener(TimelineEvent.TIMELINE_SCROLLING,timelineMoveHandler);
				timeline.addEventListener(TimelineEvent.TIMELINE_SCROLLED,timelineMoveHandler);
				
				//Update state whenever the timeline stops (do not try to update during playback)
				timeline.addEventListener(TimelineEvent.PLAYHEAD_STOPPED,dispatchUpdated);
			}
			
			/**
			 * New method for closing all shades when necessary
			 */
			protected function closeAllShades():void{
				badgeSelector.opened = false;
				locationSelector.opened = false;
				timeSelector.opened = false;
				episodesSelector.opened = false;
			}
			 
			 protected function defaultSelector():void{
			 	if(pollutantRadioGroup.getRadioButtonAt(1) != null){ 
			 		pollutantRadioGroup.getRadioButtonAt(1).selected = true; 
			 		fileBadgeListHandler();
			 	}
			 }
			
			/**
			 * New method for setting up episodes mini-timelines
			 */
			protected function setupEpisodesTimeline(eTimeline:AirQualityTimeLine):void{

				eTimeline.selections = _selections;
				
				//Add handlers for linked tooltipping between map and timeline
				var drawMapTip:Function = function(de:DataPointEvent=null):void{
						_plotLayer.drawDataTip(de.dataPoint);
					};
				var drawTimelineTip:Function = function(de:DataPointEvent=null):void{
						timeline.drawDataTip(de.dataPoint);
					};
				var drawETimelineTip:Function = function(de:DataPointEvent=null):void{
						eTimeline.drawDataTip(de.dataPoint);
					};
				var discardMapTip:Function = function(de:DataPointEvent=null):void{
						_plotLayer.discardActiveDataTip();
					};
				var discardTimelineTip:Function = function(de:DataPointEvent=null):void{
						timeline.discardActiveDataTip();
					};
				var discardETimelineTip:Function = function(de:DataPointEvent=null):void{
						eTimeline.discardActiveDataTip();
					};
				eTimeline.addEventListener(DataPointEvent.HOVER,drawMapTip,false,0,true);
				eTimeline.addEventListener(DataPointEvent.HOVER,drawTimelineTip,false,0,true);
				eTimeline.addEventListener(DataPointEvent.UNHOVER,discardMapTip,false,0,true);
				eTimeline.addEventListener(DataPointEvent.UNHOVER,discardTimelineTip,false,0,true);
				_plotLayer.addEventListener(DataPointEvent.HOVER,drawETimelineTip,false,0,true);
				_plotLayer.addEventListener(DataPointEvent.UNHOVER,discardETimelineTip,false,0,true);
				
				//handlers for popup menus on map and timeline
				eTimeline.addEventListener(DataPointEvent.CLICK,function(de:DataPointEvent):void{
						discardETimelineTip();	
						createMenu(de.mousePosition,de.dataPoint);
					},false,0,true);
				
				//remove listeners if timeline is removed from display
				eTimeline.addEventListener(FlexEvent.REMOVE, function(e:FlexEvent):void{
					eTimeline.removeEventListener(FlexEvent.REMOVE,arguments.callee);
					eTimeline.removeEventListener(DataPointEvent.HOVER,drawMapTip);
					eTimeline.removeEventListener(DataPointEvent.HOVER,drawTimelineTip);
					eTimeline.removeEventListener(DataPointEvent.UNHOVER,discardMapTip);
					eTimeline.removeEventListener(DataPointEvent.UNHOVER,discardTimelineTip);
					_plotLayer.removeEventListener(DataPointEvent.HOVER,drawETimelineTip);
					_plotLayer.removeEventListener(DataPointEvent.UNHOVER,discardETimelineTip);
					});
				
			}
			
			
			/**
			 * Loads data from a source and passes it to the timeline and map when complete.
			 *  Manages the progress bar while loading. 
			 */
			protected function loadData(source:Object,reading:String,name:String=null,onComplete:Function=null):void{
				//if this same source has already been loaded, remove it before reloading.
				for each(var d:AirQualityDataSet in _dataSets){
					if(d.dataURI == source) _dataSets.splice(_dataSets.lastIndexOf(d),1);
				}
				
				progressBar.visible = true;
				progressBar.includeInLayout = true;
				progressBar.minimum = 0;
				progressBar.setProgress(0,1);
				
				var handleProgress:Function = function(pe:ProgressEvent):void{
					progressBar.setProgress(pe.bytesLoaded,pe.bytesTotal);
					progressBar.label = (int(pe.bytesLoaded / pe.bytesTotal * 100) + 
						"% (" + pe.bytesLoaded + " of " + pe.bytesTotal + " bytes)");
				}
				
				//FIXME: Multipliers should be handled in a more intelligent way, probably provided by the resource 
				// providing the source data, since it can change from source to source even for the same reading type.
				// For now, we just assume PM data needs to be scaled up.
				var multiplier:Number = (reading == AirQualityConstants.PM_25_24HR || 
					reading == AirQualityConstants.PM_10_24HR) ? 1000 : 1; 
				
				var ds:AirQualityDataSet = new AirQualityDataSet(source,reading,name, multiplier) 
				ds.addEventListener(ProgressEvent.PROGRESS, handleProgress);
				ds.addEventListener(Event.COMPLETE, function(e:Event):void{
						progressBar.visible = false;
						progressBar.setProgress(0,1);
						progressBar.includeInLayout = false;
						_dataSets.push(ds);
						timeline.refresh(true);
						_plotLayer.refresh(true);
						dispatchUpdated();
						trace("about to set up the slider control");
						// We can set up the airQualitySlider again here
						/*
						airQualitySlider.minimum = timeline.yMin;
						airQualitySlider.maximum = timeline.yMax;
						airQualitySlider.setThumbValueAt(0, airQualitySlider.minimum);
						airQualitySlider.setThumbValueAt(1, airQualitySlider.maximum);
						*/
						// Only set all checkboxes to on if loading "first" dataset
						if(_dataSets.length == 1){
							goodBox.selected = true;
							moderateBox.selected = true;
							unhealthySensitiveBox.selected = true;
							unhealthyBox.selected = true;
							veryUnhealthyBox.selected = true;
							hazardousBox.selected = true;
							
							//reset timeline zoom because of weird state issue with old saved states
							timeline.resetZoom();
						}
						// Do this to make sure checkboxes reflect actual ranges
						airQualitySliderHandler();
						
						// Make the playback controls show up now
						playButtonBox.visible = true;
						timeline.startPlayback();
						
						if(onComplete != null){
							onComplete();
						} 
				});
			}
			
			
			/**
			 * Forces all of the loaded datasets to reload from scratch.
			 */
			protected function reloadDataSets():void{
				var oldDataSets:Vector.<AirQualityDataSet> = new Vector.<AirQualityDataSet>();
				while(_dataSets.length > 0) oldDataSets.push(_dataSets.pop());
				for each(var d:AirQualityDataSet in oldDataSets){
					loadData(d.dataURI,d.pollutant,d.name);					
				}
			}
			
			
			/** Pops up a menu that allows markers to be
			 *   added to the display.
			 */
			protected function createMenu(mousePt:Point,dataPoint:Object):void{
				
				
				//Short-term solution, always center on point click, bypassing the menu
				if(dataPoint.lat && dataPoint.lat != "None") panAndZoomTo(new Location(dataPoint.lat, dataPoint.lon),map.getZoom());
				if(dataPoint.time) timeline.centerOn(dataPoint.time);
				
				
				/* TODO: Bring all of this code back once commenting is avaliable. 
				//set up menu XML
				var menuXML:XML = XML(<root/>);
				var centerXML:XML = XML(<item/>);
				centerXML.@label = 'Center Views on This Point';	
				centerXML.@event = 'center';
				menuXML.appendChild(centerXML);
				
				//TODO:Enable Commenting functionality.
				if(_selections.isSelected(dataPoint)){
					var viewXML:XML = XML(<item/>);
					viewXML.@label = 'View Comments for this Data Point';	
					viewXML.@icon = 'CommentIcon';
					viewXML.@event = 'view';
					menuXML.appendChild(viewXML);
				}
				else{
					var addXML:XML = XML(<item/>);
					addXML.@label = 'Comment on this data point';	
					addXML.@icon = 'CommentIcon';
					addXML.@event = 'add';
					menuXML.appendChild(addXML);
				}
				
				var cancelXML:XML = XML(<item/>);
				cancelXML.@label = 'Cancel';
				cancelXML.@icon = 'CancelIcon';
				cancelXML.@event = 'cancel';
				menuXML.appendChild(cancelXML);

				//build and display menu
				var menu:Menu = Menu.createMenu(map,menuXML,false);
				menu.labelField = "@label";
				menu.iconFunction = iconFunction;
				menu.addEventListener(MenuEvent.ITEM_CLICK,function(me:MenuEvent):void{
						//When Add is clicked - add selection
						if(me.item.@event == 'add'){
							var s:Object = _selections.addSelection(dataPoint.id);
							_plotLayer.refresh(true);
							timeline.refresh(true);
						}
						//When Center is clicked - center both views on point
						else if(me.item.@event == 'center'){
							if(dataPoint.lat && dataPoint.lat != "None") panAndZoomTo(new Location(dataPoint.lat, dataPoint.lon),map.getZoom());
							if(dataPoint.time) timeline.centerOn(dataPoint.time);
						}
						//When view is clicked, focus that selection
						else if(me.item.@event == 'view'){
							var dSel:Array = _selections.getSelections(dataPoint);
							if(dSel && dSel.length > 0) dispatchEvent(new EntityEvent(EntityEvent.ENTITY_FOCUSED,dSel[0]));
							
						}
						//otherwise, hide the menu
						else menu.hide();
					});
					
	            menu.show(mousePt.x, mousePt.y);*/
			}
			
			/**
			 * Pans and zooms to a specific point and zoom level.
			 *  If this takes longer than expected, cut to the chase and just jump 
			 *  to the specified loc/zoom - this circumvents a bug where modest maps
			 *  can hang indefinitely when panning.
			 */
			protected function panAndZoomTo(loc:Location,zoom:int):void{
				
				if(_isPanningAndZooming) return; //don't try to run if one is underway
				_isPanningAndZooming = true;
				var mapZoom:int = map.getZoom();
				
				//We'll skip to the point if the pan takes 50% longer than expected. 
				var t:Timer = new Timer(1000 * map.panDuration * 1.5);
				
				//If panning completes successfully, then zoom
				var onPZPan:Function = function(me:MapEvent):void{
						map.removeEventListener(MapEvent.STOP_PANNING,onPZPan);
						map.zoomByAbout(zoom - mapZoom);
					}
				
				//If zooming completes or the timer expires, do a final recenter and dispatch events
				var onPZComplete:Function = function(e:Event=null):void{
						
						//Remove listeners
						t.stop();
						t.removeEventListener(TimerEvent.TIMER,onPZComplete);
						map.removeEventListener(MapEvent.STOP_PANNING,onPZPan);
						map.removeEventListener(MapEvent.STOP_ZOOMING,onPZComplete);
						
						
						var newCenter:Location = map.getCenter();
						var newZoom:Number = map.getZoom();
						
						//Recenter if our zooming misaligns the result of the pan
						if(!locEquals(loc,newCenter)){
							map.setCenter(loc);
						} 
						if(newZoom != zoom){
							 map.setZoom(zoom);	
						}
						
						if(!locEquals(loc,newCenter) || map.getZoom() != zoom){
							newCenter = map.getCenter(); newZoom = map.getZoom();
							trace("Error: Center and Zoom still are not correct after realign!");
						}
						
						_isPanningAndZooming = false;
						map.dispatchEvent(new CSEvent(CSEvent.PAN_AND_ZOOM_COMPLETE));
					}				
							
				//Add Listeners
				map.addEventListener(MapEvent.STOP_PANNING, onPZPan);
				map.addEventListener(MapEvent.STOP_ZOOMING, onPZComplete);
				t.addEventListener(TimerEvent.TIMER, onPZComplete);
								
				//Start the panning an timer
				t.start();
				map.panTo(loc);
			}
			
			/**
			 * Center the map (currently on the last plotted data point)
			 */
			protected function centermap():void{
				var last:Object;
				for each(var d:AirQualityDataSet in _dataSets){
					if(d.hidden) continue;
					for(var di:int=0; di < d.data.length; di++){
						var dl:Object = d.data[di];
						if((!last || last.time < dl.time) && dl.lat && dl.lon && dl.lat!="None") last = dl;
						if(_plotLayer.maxTime > 0 && dl.time >= _plotLayer.maxTime) break;
					}	
				}
				if(last) panAndZoomTo(new Location(last.lat,last.lon), map.getZoom());
			}
			
			
			/******** Implements IStatefulVis *************************************************/	
				
			protected var _setStateReady:Boolean = false;	
			public function get setStateReady():Boolean{ return _setStateReady; }
				
			
			public function get state():Object{
				var cz:Array = map.getCenterZoom();
				var cl:Location = roundLocation(cz[0] as Location);
				var ds:String;	//dataset uris
				var dsn:String;	//dataset names
				var dsp:String;	//dataset pollutants
				var dsh:String;	//dataset hidden status
				var dsorted:Array = [];
				for each(var d:AirQualityDataSet in _dataSets) dsorted.push(d);
				dsorted.sortOn("dataURI"); 
				for each(var di:AirQualityDataSet in dsorted){
					ds = (ds == null ? di.dataURI : ds + "," + di.dataURI);
					dsn = (dsn == null ? escape(di.name) : dsn + "," + escape(di.name));
					dsp = (dsp == null ? escape(di.pollutant) : dsp + "," + escape(di.pollutant));
					dsh = (dsh == null ? di.hidden.toString() : dsh + "," + di.hidden.toString());
				} 
				trace("children = " + container.numChildren);
				return {centerLat:cl.lat,
						centerLon:cl.lon,
						zoom:cz[1],
						dataSource:ds,
						dataNames:dsn,
						dataPollutants:dsp,
						dataHidden:dsh,
						xBottom:timeline.xBottom,
						xTop:timeline.xTop,
						playheadPosition:timeline.playheadPosition,
						//airQualitySliderMin:airQualitySlider.values[0],
						//airQualitySliderMax:airQualitySlider.values[1],
						goodBoxChecked:goodBox.selected,
						moderateBoxChecked:moderateBox.selected,
						unhealthySensitiveBoxChecked:unhealthySensitiveBox.selected,
						unhealthyBoxChecked:unhealthyBox.selected,
						veryUnhealthyBoxChecked:veryUnhealthyBox.selected,
						hazardousBoxChecked:hazardousBox.selected,
						episodesDisplayed:(timelinesHolder.numChildren > 0)};
			}
			
			public function set state(o:Object):void{
				// Reset all value limiters on the timeline and map to prevent weird issues with the slider
				timeline.clearLimits();
				_plotLayer.clearLimits();
				timelinesHolder.removeAllChildren(); // remove the episodes view so the new state load its own
				
				//parameters to be set once we know the data's loaded
				var onceLoaded:Function = function():void{
						//pan and zoom appropriately
						panAndZoomTo(new Location(o.centerLat,o.centerLon),o.zoom);
						
						//set hidden/visibile for each dataset
						for each(var hds:AirQualityDataSet in _dataSets){
							if(dsn.indexOf(hds.name) != -1){
								var h:Object = dsh[dsn.indexOf(hds.name)];
								hds.hidden = (h is Boolean ? h : h.toString() == "true");
							}
						}
						
						//set time bounds
						timeline.xBottom = o.xBottom;
						timeline.xTop = o.xTop;
						timeline.playheadPosition = o.playheadPosition;
						timeline.refresh();
						
						_plotLayer.minTime = o.xBottom;
						_plotLayer.maxTime = o.xTop;
						
						//load episodes (if it was displayed)
						if(o.episodesDisplayed){
							episodesHandler();
						}
						
						// Set airQualitySlider positions now that we have loaded the data
						//airQualitySlider.setThumbValueAt(0, o.airQualitySliderMin);
						//airQualitySlider.setThumbValueAt(1, o.airQualitySliderMax);
						
						// if we are trying to load an older saved state (before the checkboxes) set all true
						if(!(o.goodBoxChecked is Boolean)){
							goodBox.selected = true;
							moderateBox.selected = true;
							unhealthySensitiveBox.selected = true;
							unhealthyBox.selected = true;
							veryUnhealthyBox.selected = true;
							hazardousBox.selected = true;
						} else{
							goodBox.selected = o.goodBoxChecked;
							moderateBox.selected = o.moderateBoxChecked;
							unhealthySensitiveBox.selected = o.unhealthySensitiveBoxChecked;
							unhealthyBox.selected = o.unhealthyBoxChecked;
							veryUnhealthyBox.selected = o.veryUnhealthyBoxChecked;
							hazardousBox.selected = o.hazardousBoxChecked;
						}
						airQualitySliderHandler();
					};

				//get names, uris, pollutants, and hidden status of datasets in state
				var ds:Array = (o.dataSource is String) ? (o.dataSource as String).split(',') : null;
				var dsn:Array = (o.dataNames is String) ? (o.dataNames as String).split(',') : null;
				var dsp:Array = (o.dataPollutants is String) ? (o.dataPollutants as String).split(',') : null;
				var dsh:Array = (o.dataHidden is String) ? (o.dataHidden as String).split(',') : 
					(o.dataHidden is Boolean ? [o.dataHidden] : null);
				
				var loadingCount:int = 0;
				
				//pull old datasets
				var oldDataSets:Vector.<AirQualityDataSet> = new Vector.<AirQualityDataSet>();
				while(_dataSets.length > 0) oldDataSets.push(_dataSets.pop());
				
				//loook for specified datasets via URI
				if(ds){
					for(var i:int=0;i<ds.length;i++){
						var dsi:String = ds[i];
						//if we have an old dataset that matches, keep it
						var match:Boolean = false;
						for each(var ods:AirQualityDataSet in oldDataSets){
							if(ods.dataURI == dsi){
								match = true;
								_dataSets.push(ods);
								break;
							}
						}
						//otherwise, load from outside
						if(!match){
							loadingCount++; 
							loadData(dsi,unescape(dsp[i]),unescape(dsn[i]),function():void{
									loadingCount--;
									if(loadingCount == 0)onceLoaded();
								});
						}
					}					
				}
				if(loadingCount == 0)onceLoaded();
			}
			
			protected function dispatchComplete(e:Event = null):void{
				_setStateReady = true;
				dispatchEvent(new StatefulVisEvent(StatefulVisEvent.VIS_CREATION_COMPLETE,true));
			}
			
			protected function dispatchUpdated(e:Event = null):void{
				if(_isPanningAndZooming) return; //don't dispatch during the middle of a panAndZoom() run
				dispatchEvent(new StatefulVisEvent(StatefulVisEvent.VIS_UPDATE,true));
			}
			
			//draw a custom thumbnail for commentspace
			public function getThumbnail():BitmapData{
				var r:Rectangle = this.getBounds(this);
				var width:Number=240, height:Number=-1;
				var hasW:Boolean = width>0, hasH:Boolean = height>0;
				
				// get thumbnail dimensions
				if (hasW && !hasH) {
					height = r.height * width / r.width;
				} else if (!hasW && hasH) {
					width = r.width * height / r.height;
				} else {
					width  = hasW ? width  : (bd ? bd.width  : r.width);
					height = hasH ? height : (bd ? bd.height : r.height);
				}
				// create bitmap data as needed
				var bd:BitmapData = new BitmapData(width, height, true, 0);
				
				// determine object transformation
				var mat:Matrix = new Matrix();
				mat.translate(-r.left, -r.top);
				mat.scale(width/r.width, height/r.height);
				
				// draw the thumbnail and return
				var clipRect:Rectangle = new Rectangle(0,0,width,height);
				bd.fillRect(clipRect,0xFFDDDDDD);
				
				//FIXME: Thumb drawing breaks on the server because of crossdomain issues
				// currently we just draw the plotlayer rather than the whole map 
				mat.tx = _plotLayer.width/4 * width/r.width;
				mat.ty = _plotLayer.height/4 * height/r.height;
				bd.draw(_plotLayer,mat,null,null);
				
				//draw the timeline to the thumb
				mat.tx = timeline.x * width/r.width;
				mat.ty = timeline.y * height/r.height;
				bd.draw(timeline,mat);
				
				//draw the episodes to the thumb 
				if(timelinesHolder.visible){
					mat.tx = timelinesHolder.x * width/r.width;
					mat.ty = timelinesHolder.y * width/r.height;
					bd.draw(timelinesHolder,mat);
				}
				return bd;
			}
			
			/* Security settings - should be constrained before deployment!
			 *  These settings allow this code to be loaded into and accessed by 
			 *  a Flash movie on ANY external server. *****************************/
			Security.allowDomain("*");
			Security.allowInsecureDomain("*");
			
			
			/******** Helper Methods **********************************************************/
				
			public function onResize(event:Event):void
			{	
				var mc:Location = map.getCenter(); 
				map.setSize(this.width, this.height);
				map.setCenter(mc);
				
			}	
			
			/**Checks if two locations are equal to some level of precision */
			protected function locEquals(a:Location,b:Location,precision:uint=10):Boolean{
				return (a.lat.toPrecision(precision) == b.lat.toPrecision(precision) 
					&& a.lon.toPrecision(precision) == b.lon.toPrecision(precision));
			}
			
			/**Returns a location with lat/lon rounded to some level of precision */
			protected function roundLocation(l:Location,precision:uint=10):Location{
				return new Location(Number(l.lat.toPrecision(precision)),Number(l.lon.toPrecision(precision)));
			}
				
				
			/**
			 * A workaround which sets icons in the menus using a 
			 *  function since the standard @icon attribute in the
			 *  XML doesn't work unless the imports are at the application
			 *  root. 
			 * @param o
			 * @return 
			 * 
			 */		
			protected function iconFunction(o:Object):Class{
				if((o as XML).attributes().icon){
					var iconName:String = o.@icon;
					if(!iconName || iconName == "") return null;
					var iconClass:Class = this[iconName] as Class;
					return iconClass;				
				}
				else return null;
			}
			
			
			
			/**
			 * Triggers a disclaimer popup.
			 */
			protected function triggerDisclaimerPopup(onOkay:Function=null):void{
				var disclaimer:DisclaimerPanel = new DisclaimerPanel();
				disclaimer.onOkay = function():void{
						if(onOkay != null) onOkay();
						PopUpManager.removePopUp(disclaimer);
					};
				PopUpManager.addPopUp(disclaimer,this,true);
				PopUpManager.centerPopUp(disclaimer);
			}
			
			protected function triggerInputErrorPopup(onOkay:Function=null):void{
				var errorPanel:InputErrorPanel = new InputErrorPanel();
				errorPanel.onOkay = function():void{
						if(onOkay != null) onOkay();
						PopUpManager.removePopUp(errorPanel);
					};
				PopUpManager.addPopUp(errorPanel,this,true);
				PopUpManager.centerPopUp(errorPanel);
			}
			
			/**
			 * Triggers a popup display that allows data to be loaded from
			 *  outside.
			 */
			protected function triggerLoadingPopup():void{
				var dataPanel:DataLoadingPanel = new DataLoadingPanel();
				
				//when the okay button is clicked
				dataPanel.onLoadClick = function(e:Event=null):void{
						// added map and timeline as arguments so we can get dimensions etc.
						var info:Array = dataPanel.getSelectedInfo(map, timeline);
						if(info && info.length > 0){
							
							//clear the existing plots
							for(var ds:String in _dataSets) delete _dataSets[ds];
							_plotLayer.refresh(true);
							timeline.refresh(true);
							/*
							erroneous loading logic
							var pollutant:String = info[0].reading;
							for each (var i:Object in info) loadData(i.url,pollutant,i.name);
							*/
							trace(info[0].source);
							for each (var i:Object in info) loadData(i.source,i.reading,i.name);
						} 
						PopUpManager.removePopUp(dataPanel);
					};
					//when the cancel button is clicked
					//when the okay button is clicked
				dataPanel.onCancelClick = function(e:Event=null):void{
						PopUpManager.removePopUp(dataPanel);
					};
				PopUpManager.addPopUp(dataPanel,this,true);
				PopUpManager.centerPopUp(dataPanel);
			}
			
			/**
			 * Handles changes in the selection criteria for the various selector menus
			 */
			 
			protected function fileBadgeListHandler():void{
				/*
				if(pollutantRadioGroup.selectedValue.abbreviation == "co"){
					// Enable Location and Time selectors
					locationSelector.enabled = true;
					locationSelector.alpha = 1;
					locationSelector.label = "Location";
					timeSelector.enabled = true;
					timeSelector.alpha = 1;
					timeSelector.label = "Time";
					
					fileBadgeList.dataProvider = BADGES;
				}
				*/
				// note we include just 'pm' in the OR because originally we had user queries divided up by specific pm type...
				//else if(pollutantRadioGroup.selectedValue.abbreviation == "pm25" || pollutantRadioGroup.selectedValue.abbreviation == "pm10" || pollutantRadioGroup.selectedValue.abbreviation == "pm"){
					// Disable Location and Time selectors (since PM data is being retrieved from files right now)
					locationSelector.enabled = false;
					locationSelector.alpha = 0.5;
					locationSelector.label = "Location (disabled)";
					locationSelector.visible = false; // completely disabled for now
					
					timeSelector.enabled = false;
					timeSelector.alpha = 0.5;
					timeSelector.label = "Time (disabled)";
					timeSelector.visible = false; // completely disabled for now
					
					// Hack to make the CO selection disappear upon the forced programmatic selection of PM
					pollutantRadioGroup.getRadioButtonAt(0).visible = false;
					
					FILES = []; // delete the list
					fileBadgeList.dataProvider = FILES;
					
					/* // We use this logic if we are loading from raw pm data files
					var pmRootDir:String;
					if(pollutantRadioGroup.selectedValue.abbreviation == "pm25"){
						pmRootDir = PM_DATA_DIR + "25/"
					} else if(pollutantRadioGroup.selectedValue.abbreviation == "pm10"){
						pmRootDir = PM_DATA_DIR + "10/"
					}
					var dirRequest:URLRequest = new URLRequest(pmRootDir);
					var dirLoader:URLLoader = new URLLoader(dirRequest);
					
					dirLoader.addEventListener(Event.COMPLETE, function(e:Event):void{
							var pmSourceFiles:Array = (dirLoader.data as String).match(/(?<=href=\").+csv(?=\">)/gi);
							for(var i:int=0; i< pmSourceFiles.length; i++) {
								// populate the file/badge listing in the badge menu
								var filename:String = pmSourceFiles[i];
								trace(filename);
								
								// regex the file names with this format: 2010-02-27_10-27_2-5_8530A.csv
								var exp:RegExp = new RegExp("(\\d{4})-(\\d{2})-(\\d{2})_(\\d{2})-(\\d{2})_(\\d+)-(\\d+)_(\\w+)\\.csv", "g");
								var humanName:String = filename.replace(exp, "$8 - $2/$3/$1 at $4:$5");
								FILES.push({name:humanName, path:pmRootDir + pmSourceFiles[i]});
							}
							FILES.reverse();
							fileBadgeList.dataProvider = FILES;
					});
					*/
					
					// We use this logic to retrieve a "shift list" from the database
					var request:URLRequest = new URLRequest(BASE_SHIFT_QUERY_URL);
					var loader:URLLoader = new URLLoader(request);
					loader.addEventListener(Event.COMPLETE,function(e:Event):void{
						if(loader.data is String){
							var result:String = loader.data;
							var entries:Array = result.split(/\r|\n/gi);
							if(entries.length > 1){
								var headers:Array = (entries[0] as String).split(';'); // Note our use of semi-colons because the "name" field has commas...
								
								for(var i:int = 1; i < entries.length; i++){
									var entry:Array = (entries[i] as String).split(';'); // Note our use of semi-colons because the "name" field has commas...
									if(headers.length != entry.length && i < entries.length - 1){
										throw new Error("Row " + i + ":(" + entries[i] + ") from data source \"" + 
											BASE_SHIFT_QUERY_URL + "\" has a different number of elements than the header row:(" +
											entries[0] + ")."); 
									} 
									
									var pointData:Object = {}
									for(var h:int=0;h < headers.length;h++){
										if(headers[h] == "name"){
											// Sample regex, may not use at all...
											var exp:RegExp = new RegExp("(\\w+) \\[(\\d{4})-(\\d{2})-(\\d{2}) (\\d{2}):(\\d{2}):(\\d{2}), (\\d{4})-(\\d{2})-(\\d{2}) (\\d{2}):(\\d{2}):(\\d{2})\\]", "g");
											var humanName:String = entry[h].replace(exp, "$1 (" + entry[1] + ") $3/$4/$2 $5:$6:$7 - $9/$10/$8 $11:$12:$13"); 
											pointData[headers[h]] = humanName;
										} else
											pointData[headers[h]] = entry[h];
									} 
									FILES.push(pointData);
								}
								fileBadgeList.dataProvider = FILES;
							}
						} else
							trace("We failed to get a string from the shiftQuery");
					});			
					
				//}
			}
			
			protected function selectorHandler(fromLocationHandler:Boolean):void{
				// Reset all value limiters on the timeline and map to prevent weird issues with the slider
				timeline.clearLimits();
				_plotLayer.clearLimits();
				
				//clear the existing plots... (why do we do this?)
				for(var ds:String in _dataSets) delete _dataSets[ds];
				_plotLayer.refresh(true);
				timeline.refresh(true);
				
				//choose whether we should center the map or not based off whether we used location service
				var onCompleteFunc:Function;
				if(fromLocationHandler){
					onCompleteFunc = function():void{dispatchComplete();}; // don't re-center the map on the last point if we used locationselector
				} else{
					onCompleteFunc = function():void{centermap();dispatchComplete();};
				}
				
				// TODO will eventually integrate pm data so its from a badge, just like co data...
				// note we include just 'pm' in the OR because originally we had user queries divided up by specific pm type...
				if(pollutantRadioGroup.selectedValue.abbreviation == "pm25" || pollutantRadioGroup.selectedValue.abbreviation == "pm10" || pollutantRadioGroup.selectedValue.abbreviation == "pm"){
					
					// If we already have the file list... take the selected ones and load them up
					if(FILES.length > 0){
						for each(var file:Object in fileBadgeList.selectedItems){
							//loadData(file.path, pollutantRadioGroup.selectedValue.abbreviation, file.name, onCompleteFunc); // Instead of loading from files, we load from database!
							if(file.filter == '10.0' || file.filter == '2.5'){
								var filter_type:String = file.filter == '10.0' ? 'pm10' : 'pm25';
								loadData(buildPmQueryURL(file.utcstart, file.utcend, file.device, file.filter), filter_type, file.name, onCompleteFunc);
							}
							else{
								// pm1 and pm40 currently unsupported!
								triggerInputErrorPopup();
							}
						}
					} else{
						trace("file list not populated, cannot load anything from it.");
					}
				}
				else{
					var info:Array = []
					if(fileBadgeList.selectedItems.length > 0 && pollutantRadioGroup.selectedValue != null){
						for each(var b:Object in fileBadgeList.selectedItems){
						info.push({name:buildName(b.name),
								   source:buildURL(map, timeline, b.id),
								   reading:pollutantRadioGroup.selectedValue.abbreviation});
						}
						// alright, we're ready to load everything for each badge!
						trace(info[0].source);
						for each (var i:Object in info) loadData(i.source,i.reading,i.name, onCompleteFunc); // prevent re-centering
					} else{
						triggerInputErrorPopup();
					}
				}
				
				
			}
			
			protected function locationHandler():void{
				// Set center on map first so window metadata is correct for final backend query
				var request:URLRequest = new URLRequest("http://maps.google.com/maps/geo?q=" + location.text + "&output=csv&oe=utf8&sensor=false&key=" + GOOGLE_API_KEY);
				trace("Query to google: " + "http://maps.google.com/maps/geo?q=" + location.text + "&output=csv&oe=utf8&sensor=false&key=" + GOOGLE_API_KEY);
				var loader:URLLoader = new URLLoader(request);
				var geocodeReturn:Array;
				
				loader.addEventListener(ProgressEvent.PROGRESS,function(pe:ProgressEvent):void{
						trace("Searching...");	
				});
				
				loader.addEventListener(Event.COMPLETE, 
				function(e:Event){
					geocodeReturn = loader.data.split(',');
					
					if(!(geocodeReturn[2] == '0' || geocodeReturn[3] == '0')){
						trace(loader.data);
					} else
						trace("Location Invalid!");
					
					map.setCenter(new Location(Number(geocodeReturn[2]),Number(geocodeReturn[3])));
					selectorHandler(true); // now that it's centered, we can load things normally!
				});
				
				//FIXME:quick default handler which catches the errors thrown when running on the web
				// (Flash's security model won't allow access to the google API) and defaults to a set location.
				loader.addEventListener(SecurityErrorEvent.SECURITY_ERROR, function(e:Event){
					geocodeReturn = [0,0,37.813191355256826, -122.2976803779602];
					map.setCenter(new Location(Number(geocodeReturn[2]),Number(geocodeReturn[3])));
					selectorHandler(true);
				});
			}
			
			protected function airQualitySliderHandler():void{
				// update the timeline and plotlayer
				/*
				timeline.yMin = airQualitySlider.values[0];
				timeline.yMax = airQualitySlider.values[1];
				_plotLayer.yMin = airQualitySlider.values[0];
				_plotLayer.yMax = airQualitySlider.values[1];
				*/
				
				timeline.yMin = Infinity;
				timeline.yMax = Infinity;
				_plotLayer.yMin = Infinity;
				_plotLayer.yMax = Infinity;
				
				var threshold:Array = AirQualityColors.POLLUTANT_INDEX[_dataSets[0].pollutant];
				if(goodBox.selected){
					timeline.yMin = threshold[0];
					timeline.yMax = threshold[1];
					_plotLayer.yMin = threshold[0];
					_plotLayer.yMax = threshold[1];
				} 
				if(moderateBox.selected){
					if(timeline.yMin < Infinity && _plotLayer.yMin < Infinity){
						timeline.yMax = threshold[2];
						_plotLayer.yMax = threshold[2];
					}
					else{
						timeline.yMin = threshold[1];
						timeline.yMax = threshold[2];
						_plotLayer.yMin = threshold[1];
						_plotLayer.yMax = threshold[2];
					}
				}
				if(unhealthySensitiveBox.selected){
					if(timeline.yMin < Infinity && _plotLayer.yMin < Infinity){
						timeline.yMax = threshold[3];
						_plotLayer.yMax = threshold[3];
					}
					else{
						timeline.yMin = threshold[2];
						timeline.yMax = threshold[3];
						_plotLayer.yMin = threshold[2];
						_plotLayer.yMax = threshold[3];
					}
				}
				if(unhealthyBox.selected){
					if(timeline.yMin < Infinity && _plotLayer.yMin < Infinity){
						timeline.yMax = threshold[4];
						_plotLayer.yMax = threshold[4];
					}
					else{
						timeline.yMin = threshold[3];
						timeline.yMax = threshold[4];
						_plotLayer.yMin = threshold[3];
						_plotLayer.yMax = threshold[4];
					}
				}
				if(veryUnhealthyBox.selected){
					if(timeline.yMin < Infinity && _plotLayer.yMin < Infinity){
						timeline.yMax = threshold[5];
						_plotLayer.yMax = threshold[5];
					}
					else{
						timeline.yMin = threshold[4];
						timeline.yMax = threshold[5];
						_plotLayer.yMin = threshold[4];
						_plotLayer.yMax = threshold[5];
					}
				}
				if(hazardousBox.selected){
					if(timeline.yMin < Infinity && _plotLayer.yMin < Infinity){
						timeline.yMax = Infinity;
						_plotLayer.yMax = Infinity;
					}
					else{
						timeline.yMin = threshold[4];
						timeline.yMax = Infinity;
						_plotLayer.yMin = threshold[4];
						_plotLayer.yMax = Infinity;
					}
				}
				
				// referesh both the timeline and the plotlayer now that we're done messing with them
				timeline.refresh(false); // we choose false to avoid the timeline recalculating the min/maxes for us
				_plotLayer.refresh(false); // we choose false to avoid rebuilding the quadtree
				
				dispatchUpdated(); // called for IStatefulVis
			}
			
			protected function episodesHandler():void{
				// Add a button for removing the episodes pane
				var remover:mx.controls.Button = new mx.controls.Button();
				remover.label = "✕";
				remover.height = 28;
				remover.setStyle("cornerRadius", "10");
				remover.toolTip = "remove episodes from view";
				remover.addEventListener(MouseEvent.CLICK, destroyEpisodes);
				timelinesHolder.addChild(remover);
				
				if(_dataSets.length > 0){
					timelinesHolder.width = 300; // set the width only when there ARE episodes in there
					var ds:AirQualityDataSet = _dataSets[0]; // FIXME only looks at the first plotted data set right now
					var peaks:Array = ds.stats.getSpikes();
					addTimelines(peaks.slice(Math.max(peaks.length-11,0),Math.max(peaks.length-1,0)));
				} else{
					triggerInputErrorPopup();
				}
			}
			
			protected function destroyEpisodes(e:Event=null):void{
				timelinesHolder.removeAllChildren();
				timelinesHolder.width = 0;
				dispatchUpdated(); // called for IStatefulVis
			}
			
			protected function addTimelines(episodes:Array):void{
				episodes = episodes.reverse();
				var epIndex:Object = {};
				for each(var e:Object in episodes){
					var t:AirQualityTimeLine = new AirQualityTimeLine();
					t.percentWidth = 100;
					t.height = timelinesHolder.height * 0.95 / episodes.length;
					t.margin = 8;
					t.noControls = true;
					t.dataSets = _dataSets;
					t.xBottom = e.beginTime;
					t.xTop = e.endTime;
					
					timelinesHolder.addChild(t);
					t.addEventListener(FlexEvent.CREATION_COMPLETE, function(fe:FlexEvent):void{
							var tl:AirQualityTimeLine = fe.target as AirQualityTimeLine;
							setupEpisodesTimeline(tl);
							t.setStyle("borderStyle","solid");
							t.setStyle("borderColor",0xFFFFFFFF);
							tl.refresh();
							dispatchUpdated(); // to update IStatefulVis
						},false,0,true);
					
					//label
					var l:Label = new Label();
					var eTime:Date = new Date(e.beginTime*1000);
					l.htmlText = eTime.toLocaleDateString() + " <b>" + eTime.toLocaleTimeString() + "</b>";
					l.setStyle("paddingTop",-t.height);
					l.setStyle("paddingBottom",t.height - 15);
					l.setStyle("color","0x666666");
					timelinesHolder.addChild(l);	
						
					/* t.addEventListener(MouseEvent.MOUSE_OVER, function(fme:Event):void{
							var tm:AirQualityTimeLine = fme.currentTarget as AirQualityTimeLine;
							_plotLayer.minTime = tm.xBottom;
							_plotLayer.maxTime = tm.xTop;
						});
					t.addEventListener(MouseEvent.MOUSE_OUT, function(foe:Event):void{
							_plotLayer.minTime = int.MIN_VALUE;
							_plotLayer.maxTime = int.MAX_VALUE;
							_plotLayer.refresh();
						});		
						
					t.addEventListener(DataPointEvent.HOVER, function(fde:DataPointEvent):void{
							panAndZoomTo(new Location(fde.dataPoint.lat, fde.dataPoint.lon),map.getZoom());
						});	 */	
						
				}
			}
			
			protected function buildURL(map:TweenMap, timeline:AirQualityTimeLine, badgeId:String=null):String{
				var url:String = BASE_DB_QUERY_URL + "?badge_id=" + (badgeId ? badgeId : fileBadgeList.selectedItem.id) + 
				 		"&reading=" + pollutantRadioGroup.selectedValue.db; 
				if(dateChooser.selectedRanges.length > 0 && dateChooser.selectedRanges[0]){
					url += "&start_time=" + (dateChooser.selectedRanges[0].rangeStart as Date).time / 1000 +
						"&end_time=" + ((dateChooser.selectedRanges[0].rangeEnd as Date).time / 1000 + 3600 * 24) +					
						"&lat_min=" + map.getExtent().south +
						"&lat_max=" + map.getExtent().north +
						"&lon_min=" + map.getExtent().west + 
						"&lon_max=" + map.getExtent().east +
						"&window_width=" + map.width + 
						"&window_height=" + map.height +
						"&timeline_length=" + timeline.width +
						"&timeline_height=" + timeline.height;
				}
				trace(url);		 		
				return url;
			}
			
			protected function buildPmQueryURL(start_time:String, end_time:String, device_id:String, filter_type:String):String{
				var url:String = BASE_PM_QUERY_URL + "?start_time=" + start_time + "&end_time=" + end_time + "&device_id=" + device_id + "&filter_type=" + filter_type;
				trace(url);	
				return url;
			}
			
			protected function buildName(badgeName:String):String{
				var name:String = badgeName + " " + pollutantRadioGroup.selectedValue.pollutant;
				if(dateChooser.selectedRanges.length > 0 && dateChooser.selectedRanges[0]){
					name += (" (" + (dateChooser.selectedRanges[0].rangeStart as Date).toLocaleDateString() + " - " + 
			       			(dateChooser.selectedRanges[0].rangeEnd as Date).toLocaleDateString() + ")");
				}				 		
				return name;
			}
			
		]]>
	</mx:Script>
	<mx:Style source="assets/commonsensestyles.css"/>
	
</mx:Application>
